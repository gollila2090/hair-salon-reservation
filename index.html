<!DOCTYPE html>
<html lang="ko" class="light"> <!-- Default to light mode -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ï†ïÍ∏∞Ìôî Ìó§Ïñ¥ ÏòàÏïΩ ÏãúÏä§ÌÖú</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Base styles for light mode */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc; /* Very light blue-gray background */
        }
        /* .container custom CSS removed as replaced by Tailwind classes */
        .btn-primary {
            background-color: #8b5cf6; /* Violet 500 */
            color: white;
        }
        .btn-secondary {
            background-color: #e2e8f0; /* Slate 200 */
            color: #475569; /* Slate 700 */
        }
        .input-field {
            border-color: #cbd5e1; /* Slate 300 */
            background-color: #ffffff;
            color: #1f2937; /* Gray 800 */
        }
        .input-field:focus {
            border-color: #8b5cf6; /* Violet 500 on focus */
        }
        .time-slot-item.booked {
            background-color: #fef2f2; /* Red 50 */
            color: #dc2626; /* Red 600 */
            border-color: #fca5a5; /* Red 300 */
        }
        .time-slot-item.available {
            background-color: #ecfdf5; /* Green 50 */
            color: #10b981; /* Green 600 */
            border-color: #a7f3d0; /* Green 300 */
        }
        /* New style for blocked time slots */
        .time-slot-item.blocked {
            background-color: #f0f4f8; /* Light gray */
            color: #64748b; /* Slate 600 */
            border-color: #cbd5e1; /* Slate 300 */
            cursor: pointer; /* Still clickable to unblock */
        }
        .time-slot-item.blocked:hover {
            background-color: #e2e8f0; /* Slate 200 on hover */
        }
        /* Style for past time slots (updated color) */
        .time-slot-item.past-slot {
            background-color: #e0e0e0; /* Lighter grey for light mode */
            color: #616161; /* Darker grey text */
            border-color: #bdbdbd; /* Medium grey border */
            cursor: not-allowed; /* Indicate not clickable for booking */
            opacity: 0.7; /* Slightly dim past slots */
        }
        .time-slot-item.past-slot:hover {
            transform: none; /* No lift effect on past slots */
            box-shadow: none; /* No shadow change on past slots */
        }

        .modal-content {
            background-color: #fefefe;
        }
        .close-button {
            color: #94a3b8; /* Slate 400 */
        }

        /* Dark mode styles (applied when html has 'dark' class) */
        .dark body {
            background-color: #1a202c; /* Dark gray */
        }
        /* .dark .container custom CSS removed as replaced by Tailwind classes */
        .dark .btn-primary {
            background-color: #7c3aed; /* Violet 600 */
            color: white;
        }
        .dark .btn-primary:hover {
            background-color: #6d28d9; /* Violet 700 */
        }
        .dark .input-field {
            border-color: #475569; /* Slate 700 */
            background-color: #334155; /* Slate 800 */
            color: #e2e8f0; /* Light text */
        }
        .dark .input-field:focus {
            border-color: #a78bfa; /* Violet 400 on focus */
        }
        .dark .time-slot-item.booked {
            background-color: #450a0a; /* Red 950 */
            color: #fca5a5; /* Red 300 */
            border-color: #7f1d1d; /* Red 800 */
        }
        .dark .time-slot-item.available {
            background-color: #064e3b; /* Green 900 */
            color: #6ee7b7; /* Green 300 */
            border-color: #065f46; /* Green 800 */
        }
        /* New dark mode style for blocked time slots */
        .dark .time-slot-item.blocked {
            background-color: #334155; /* Slate 800 */
            color: #94a3b8; /* Slate 400 */
            border-color: #475569; /* Slate 700 */
        }
        .dark .time-slot-item.blocked:hover {
            background-color: #1e293b; /* Slate 900 on hover */
        }
        /* Dark mode style for past time slots (updated color) */
        .dark .time-slot-item.past-slot {
            background-color: #424242; /* Darker grey for dark mode */
            color: #9e9e9e; /* Lighter grey text */
            border-color: #616161; /* Medium grey border */
        }
        .dark .time-slot-item.past-slot:hover {
            transform: none;
            box-shadow: none;
        }

        /* Common styles (apply to both modes) */
        /* .container common CSS removed as replaced by Tailwind classes */
        .btn-primary {
            padding: 0.85rem 1.75rem; /* Increased padding for better touch target */
            border-radius: 0.75rem; /* More rounded buttons */
            font-weight: 600;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .btn-primary:hover {
            transform: translateY(-1px);
        }
        .btn-secondary {
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: 500;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        }
        .btn-secondary:hover {
            transform: translateY(-1px);
        }
        .input-field {
            padding: 0.85rem; /* Increased padding */
            border-width: 1px;
            border-radius: 0.75rem; /* More rounded */
            width: 100%;
            box-sizing: border-box;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }
        .time-slot-item {
            transition: background-color 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease;
            padding: 1.25rem; /* More padding for better touch experience */
            border-radius: 1rem; /* Even more rounded */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05), 0 2px 4px -1px rgba(0, 0, 0, 0.03); /* Subtle shadow for each slot */
        }
        .time-slot-item:hover {
            transform: translateY(-3px); /* More pronounced lift */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .time-slot-item .status-text {
            font-weight: 600; /* Make status text bolder */
        }

        .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 1000; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0,0,0,0.5); /* Darker overlay */
            justify-content: center;
            align-items: center;
            padding: 1rem; /* Padding for modal on small screens */
        }
        .modal-content {
            padding: 2.5rem; /* More padding */
            border-radius: 1.5rem; /* More rounded */
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25); /* Stronger shadow */
            width: 95%; /* Wider modal on mobile */
            max-width: 550px; /* Max width for larger screens */
            text-align: center;
            position: relative; /* For close button positioning */
        }
        .close-button {
            position: absolute;
            top: 1rem;
            right: 1.5rem;
            font-size: 2.25rem; /* Larger close button */
            font-weight: bold;
            cursor: pointer;
            transition: color 0.2s ease;
        }
        .close-button:hover,
        .close-button:focus {
            color: #475569; /* Slate 700 */
        }
        .modal-content h3 {
            margin-bottom: 1.5rem;
            font-size: 1.875rem; /* Larger modal title */
        }
        .modal-content p {
            margin-bottom: 1rem;
        }
    </style>
</head>
<body class="bg-f8fafc dark:bg-gray-900">
    <div class="max-w-4xl mx-auto p-6 md:p-8 lg:p-10 rounded-3xl shadow-xl bg-white dark:bg-gray-800 text-gray-800 dark:text-gray-100">
        <div class="flex justify-end mb-4">
            <button id="themeToggle" class="btn-secondary px-4 py-2 text-sm">
                <span id="themeIcon">üåô</span> <span id="themeText">Îã§ÌÅ¨ Î™®Îìú</span>
            </button>
        </div>

        <h1 class="text-5xl md:text-6xl font-extrabold text-center mb-8 bg-gradient-to-r from-purple-500 to-pink-500 text-transparent bg-clip-text tracking-tight">
            Ï†ïÍ∏∞Ìôî Ìó§Ïñ¥ ÏòàÏïΩ ÏãúÏä§ÌÖú
        </h1>

        <div class="mb-8 p-5 bg-purple-50 border border-purple-200 rounded-xl text-purple-800 text-base shadow-sm dark:bg-purple-900 dark:border-purple-700 dark:text-purple-200">
            <p class="font-semibold">ÏÇ¨Ïö©Ïûê ID: <span id="userIdDisplay" class="font-normal text-purple-700 dark:text-purple-300">Î°úÎî© Ï§ë...</span></p>
            <p class="mt-3 text-sm text-purple-700 dark:text-purple-300">Ïù¥ IDÎäî Ïï±Ïùò Îç∞Ïù¥ÌÑ∞Î•º Í¥ÄÎ¶¨ÌïòÎäî Îç∞ ÏÇ¨Ïö©Îê©ÎãàÎã§. Îã§Î•∏ ÏÇ¨Ïö©ÏûêÏôÄ Ïù¥ Ïï±ÏùÑ Í≥µÏú†ÌïòÎ†§Î©¥ Ïù¥ IDÎ•º ÏïåÎ†§Ï£ºÏÑ∏Ïöî.</p>
        </div>

        <!-- Date Selection -->
        <div class="mb-8">
            <label for="selectedDate" class="block text-xl font-semibold mb-3">ÎÇ†Ïßú ÏÑ†ÌÉù</label>
            <input type="date" id="selectedDate" class="input-field">
        </div>

        <!-- Reservation List and Time Slots -->
        <div class="grid grid-cols-1 gap-6 mb-8">
            <!-- Available Time Slots -->
            <div>
                <h2 class="text-xl font-semibold mb-5">ÏòàÏïΩ ÌòÑÌô©</h2>
                <!-- Modified timeSlots div for 2 columns per row -->
                <div id="timeSlots" class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                    <!-- Time slots will be dynamically loaded here -->
                    <p class="text-gray-500 dark:text-gray-400 text-lg sm:col-span-2">ÎÇ†ÏßúÎ•º ÏÑ†ÌÉùÌïòÏó¨ ÏòàÏïΩ Í∞ÄÎä•Ìïú ÏãúÍ∞ÑÏùÑ ÌôïÏù∏ÌïòÏÑ∏Ïöî.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Custom Message Modal -->
    <div id="messageModal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <p id="modalMessage" class="text-xl mb-6"></p>
            <button id="modalConfirmBtn" class="btn-primary mt-4 hidden">ÌôïÏù∏</button>
        </div>
    </div>

    <!-- Booking Management Modal -->
    <div id="bookingManagementModal" class="modal">
        <div class="modal-content">
            <span class="close-button booking-modal-close">&times;</span>
            <h3 id="bookingModalTitle" class="text-3xl font-semibold mb-6"></h3>

            <!-- Form for New Booking / Blocking Time -->
            <div id="newBookingOrBlockForm" class="space-y-6 text-left">
                <p class="text-lg text-center">ÏÑ†ÌÉùÌïòÏã† ÏãúÍ∞ÑÎåÄÏóê ÏòàÏïΩÏùÑ Ï∂îÍ∞ÄÌïòÏãúÍ≤†ÏäµÎãàÍπå?</p>
                <div>
                    <label for="serviceSelect" class="block font-medium mb-2">ÏÑúÎπÑÏä§</label>
                    <select id="serviceSelect" class="input-field" required>
                        <!-- Options will be populated by JS -->
                    </select>
                </div>
                <!-- Input for 'Í∏∞ÌÉÄ' service -->
                <div id="otherServiceInputContainer" class="hidden">
                    <label for="otherServiceInput" class="block font-medium mb-2">Í∏∞ÌÉÄ ÏÑúÎπÑÏä§ ÎÇ¥Ïö©:</label>
                    <input type="text" id="otherServiceInput" class="input-field" placeholder="Ïòà: Î∂ôÏûÑÎ®∏Î¶¨ Ï†úÍ±∞">
                </div>
                <!-- Input for 'Í∞úÏù∏ ÏãúÍ∞Ñ/Ìú¥Ïãù ÏãúÍ∞Ñ' reason -->
                <div id="blockReasonInputContainer" class="hidden">
                    <label for="blockReasonInput" class="block font-medium mb-2">Ïû†Í∏à ÏÇ¨Ïú† (ÏÑ†ÌÉù ÏÇ¨Ìï≠):</label>
                    <input type="text" id="blockReasonInput" class="input-field" placeholder="Ïòà: Ï†êÏã¨ÏãúÍ∞Ñ, Ïû¨Î£å Ï†ïÎ¶¨">
                </div>
                <button id="confirmActionBtn" class="btn-primary w-full">ÌôïÏù∏</button>
            </div>

            <!-- Details for Existing Booking / Blocked Time -->
            <div id="existingDetails" class="space-y-4 text-left">
                <p class="text-lg"><strong>ÏãúÍ∞Ñ:</strong> <span id="detailTime" class="font-semibold"></span></p>
                <p class="text-lg"><strong>ÎÇ¥Ïö©:</strong> <span id="detailContent" class="font-semibold"></span></p>
                <p class="text-lg"><strong>ÏÉÅÌÉú:</strong> <span id="detailStatus" class="font-semibold"></span></p>
                <div class="flex flex-col sm:flex-row justify-center space-y-4 sm:space-y-0 sm:space-x-4 mt-8">
                    <button id="markCompleteBtnModal" class="btn-primary hidden">ÏôÑÎ£å ÌëúÏãú</button>
                    <button id="unblockTimeBtnModal" class="btn-primary hidden">Ïû†Í∏à Ìï¥Ï†ú</button>
                    <button id="deleteReservationBtnModal" class="btn-secondary hidden">ÏÇ≠Ï†ú</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, addDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, where, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Firebase Configuration (ReplitÍ≥º Í∞ôÏùÄ Ïô∏Î∂Ä ÌôòÍ≤ΩÏóê Î∞∞Ìè¨Ìï† Í≤ΩÏö∞, ÏïÑÎûò Í∞íÎì§ÏùÑ Ïã§Ï†ú Firebase ÌîÑÎ°úÏ†ùÌä∏ ÏÑ§Ï†ïÏúºÎ°ú ÎåÄÏ≤¥Ìï¥Ïïº Ìï©ÎãàÎã§.)
        // 1. Firebase ÏΩòÏÜî(console.firebase.google.com)ÏóêÏÑú ÌîÑÎ°úÏ†ùÌä∏Î•º ÏÉùÏÑ±Ìï©ÎãàÎã§.
        // 2. ÌîÑÎ°úÏ†ùÌä∏ ÏÑ§Ï†ïÏóêÏÑú 'Ïõπ Ïï±'ÏùÑ Ï∂îÍ∞ÄÌïòÍ≥†, Ï†úÍ≥µÎêòÎäî Íµ¨ÏÑ± Í∞ùÏ≤¥Î•º Î≥µÏÇ¨Ìï©ÎãàÎã§.
        // 3. Î≥µÏÇ¨Ìïú Íµ¨ÏÑ± Í∞ùÏ≤¥ ÎÇ¥Ïùò 'apiKey', 'authDomain', 'projectId', 'storageBucket', 'messagingSenderId', 'appId' Í∞íÏùÑ
        //    ÏïÑÎûò 'firebaseConfig' Í∞ùÏ≤¥Ïóê Ï†ïÌôïÌûà Î∂ôÏó¨ÎÑ£ÏúºÏÑ∏Ïöî.
        // 4. 'appId' Î≥ÄÏàòÎäî Firebase ÌîÑÎ°úÏ†ùÌä∏ ID (firebaseConfig.projectId)ÏôÄ ÎèôÏùºÌïòÍ≤å ÏÑ§Ï†ïÌïòÎäî Í≤ÉÏù¥ Ï¢ãÏäµÎãàÎã§.
        const appId = 'hair-salon-reservation'; // Ïã§Ï†ú Firebase Project IDÎ°ú Î≥ÄÍ≤ΩÌïòÏÑ∏Ïöî.
        const firebaseConfig = {
            apiKey: "AIzaSyCjpIkmwKk3rXf89dsgqh2nvoAggHvdX_k", // Ïã§Ï†ú Firebase API ÌÇ§Î°ú Î≥ÄÍ≤ΩÌïòÏÑ∏Ïöî.
            authDomain: "hair-salon-reservation.firebaseapp.com", // Ïã§Ï†ú Firebase Auth DomainÏúºÎ°ú Î≥ÄÍ≤ΩÌïòÏÑ∏Ïöî.
            projectId: "hair-salon-reservation", // Ïã§Ï†ú Firebase Project IDÎ°ú Î≥ÄÍ≤ΩÌïòÏÑ∏Ïöî.
            storageBucket: "hair-salon-reservation.firebasestorage.app", // Ïã§Ï†ú Firebase Storage BucketÏúºÎ°ú Î≥ÄÍ≤ΩÌïòÏÑ∏Ïöî.
            messagingSenderId: "898483539072", // Ïã§Ï†ú Firebase Messaging Sender IDÎ°ú Î≥ÄÍ≤ΩÌïòÏÑ∏Ïöî.
            appId: "1:898483539072:web:07b097beeccf63cdee6a65" // Ïã§Ï†ú Firebase App IDÎ°ú Î≥ÄÍ≤ΩÌïòÏÑ∏Ïöî. (firebaseConfig.projectIdÏôÄ ÎèôÏùºÌïòÍ≤å ÏÑ§Ï†ïÌïòÎäî Í≤ÉÏù¥ ÏùºÎ∞òÏ†ÅÏûÖÎãàÎã§.)
        };
        const initialAuthToken = null; // ReplitÍ≥º Í∞ôÏùÄ Ïô∏Î∂Ä ÌôòÍ≤ΩÏóêÏÑúÎäî initialAuthTokenÏù¥ Ï†úÍ≥µÎêòÏßÄ ÏïäÏúºÎØÄÎ°ú Ïù¥ Í∞íÏùÄ nullÎ°ú Ïú†ÏßÄÌï©ÎãàÎã§.

        console.log("Firebase config:", firebaseConfig); // Firebase ÏÑ§Ï†ï Î°úÍπÖ
        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        console.log("Firebase app initialized:", app); // Firebase Ïï± Ï¥àÍ∏∞Ìôî Î°úÍπÖ

        const db = getFirestore(app);
        const auth = getAuth(app);

        let currentUserId = null;
        let unsubscribe = null; // Stores the unsubscribe function for Firestore listener

        // DOM Elements
        const selectedDateInput = document.getElementById('selectedDate');
        const timeSlotsDiv = document.getElementById('timeSlots');
        const userIdDisplay = document.getElementById('userIdDisplay');

        // Theme Toggle Elements
        const themeToggle = document.getElementById('themeToggle');
        const themeIcon = document.getElementById('themeIcon');
        const themeText = document.getElementById('themeText');

        // Message Modal Elements
        const messageModal = document.getElementById('messageModal');
        const modalMessage = document.getElementById('modalMessage');
        const closeButton = document.querySelector('#messageModal .close-button');
        const modalConfirmBtn = document.getElementById('modalConfirmBtn');

        // Booking Management Modal Elements
        const bookingManagementModal = document.getElementById('bookingManagementModal');
        const bookingModalTitle = document.getElementById('bookingModalTitle');
        const newBookingOrBlockForm = document.getElementById('newBookingOrBlockForm');
        const existingDetails = document.getElementById('existingDetails');
        const serviceSelect = document.getElementById('serviceSelect');
        const otherServiceInputContainer = document.getElementById('otherServiceInputContainer');
        const otherServiceInput = document.getElementById('otherServiceInput');
        const blockReasonInputContainer = document.getElementById('blockReasonInputContainer');
        const blockReasonInput = document.getElementById('blockReasonInput');
        const confirmActionBtn = document.getElementById('confirmActionBtn');
        const markCompleteBtnModal = document.getElementById('markCompleteBtnModal');
        const unblockTimeBtnModal = document.getElementById('unblockTimeBtnModal');
        const deleteReservationBtnModal = document.getElementById('deleteReservationBtnModal');
        const bookingModalCloseButton = document.querySelector('#bookingManagementModal .booking-modal-close');

        // Detail elements for existing booking/block
        const detailTime = document.getElementById('detailTime');
        const detailContent = document.getElementById('detailContent');
        const detailStatus = document.getElementById('detailStatus');

        let currentSelectedSlotTime = null;
        let currentSelectedReservationId = null;
        let currentSelectedReservationStatus = null;

        // Define available services
        const availableServices = [
            'ÎÇ®Ïûê Ïª∑',
            'Ïó¨Ïûê Ïª∑',
            'ÎÇ®Ïûê ÌååÎßà',
            'Ïó¨Ïûê ÌååÎßà',
            'ÏóºÏÉâ',
            'ÌÅ¥Î¶¨Îãâ',
            'Í∏∞ÌÉÄ',
            'Í∞úÏù∏ ÏãúÍ∞Ñ/Ìú¥Ïãù ÏãúÍ∞Ñ Ïû†Í∏à'
        ];

        // Function to set theme
        function setTheme(theme) {
            if (theme === 'dark') {
                document.documentElement.classList.add('dark');
                themeIcon.textContent = '‚òÄÔ∏è';
                themeText.textContent = 'ÎùºÏù¥Ìä∏ Î™®Îìú';
            } else {
                document.documentElement.classList.remove('dark');
                themeIcon.textContent = 'üåô';
                themeText.textContent = 'Îã§ÌÅ¨ Î™®Îìú';
            }
            localStorage.setItem('theme', theme);
        }

        // Load theme on page load
        const savedTheme = localStorage.getItem('theme') || 'light';
        setTheme(savedTheme);

        // Toggle theme on button click
        themeToggle.addEventListener('click', () => {
            const currentTheme = document.documentElement.classList.contains('dark') ? 'dark' : 'light';
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';
            setTheme(newTheme);
        });

        // Function to show custom message modal
        // autoHide: trueÎ©¥ ÏßßÏùÄ ÏãúÍ∞Ñ ÌõÑ ÏûêÎèô Îã´Ìûò, falseÎ©¥ ÏÇ¨Ïö©ÏûêÍ∞Ä Îã´ÏùÑ ÎïåÍπåÏßÄ Ïú†ÏßÄ
        function showMessageModal(message, isConfirm = false, onConfirm = null, autoHide = true) {
            modalMessage.textContent = message;
            console.log(`[showMessageModal] Called with message: "${message}", isConfirm: ${isConfirm}, autoHide: ${autoHide}`); // Debug log

            if (isConfirm) {
                modalConfirmBtn.classList.remove('hidden');
                modalConfirmBtn.onclick = () => {
                    console.log("[showMessageModal] Confirm button clicked. Hiding modal.");
                    messageModal.style.display = 'none'; // Hide modal immediately
                    modalConfirmBtn.classList.add('hidden'); // Hide button
                    if (onConfirm) {
                        console.log("[showMessageModal] Executing onConfirm callback.");
                        onConfirm();
                    }
                };
                messageModal.style.display = 'flex'; // Show the modal
            } else {
                modalConfirmBtn.classList.add('hidden'); // Ensure confirm button is hidden
                modalConfirmBtn.onclick = null; // Clear any previous click handler
                messageModal.style.display = 'flex'; // Show the modal

                if (autoHide) {
                    console.log("[showMessageModal] Showing non-confirm message with auto-hide.");
                    setTimeout(() => {
                        console.log("[showMessageModal] Auto-hiding non-confirm message.");
                        messageModal.style.display = 'none'; // Auto-hide after 0.5 seconds
                    }, 500); // 0.5Ï¥à ÌõÑ ÏûêÎèô Îã´Í∏∞
                } else {
                    console.log("[showMessageModal] Showing non-confirm message without auto-hide.");
                    // Do nothing, modal stays until 'X' or outside click
                }
            }
        }

        // Function to hide message modal
        function hideMessageModal() {
            console.log("[hideMessageModal] Hiding message modal.");
            messageModal.style.display = 'none';
        }

        // Close message modal when close button is clicked
        closeButton.onclick = () => {
            hideMessageModal();
        };

        // Close message modal when clicking outside
        window.addEventListener('click', (event) => {
            if (event.target == messageModal) {
                hideMessageModal();
            }
        });

        // Function to populate service select dropdown
        function populateServiceSelect() {
            serviceSelect.innerHTML = '<option value="">ÏÑúÎπÑÏä§Î•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî</option>';
            availableServices.forEach(service => {
                const option = document.createElement('option');
                option.value = service;
                option.textContent = service;
                serviceSelect.appendChild(option);
            });
        }

        // Event listener for service select change to show/hide other service/block reason inputs
        serviceSelect.addEventListener('change', () => {
            otherServiceInputContainer.classList.add('hidden');
            otherServiceInput.removeAttribute('required');
            otherServiceInput.value = '';

            blockReasonInputContainer.classList.add('hidden');
            blockReasonInput.value = '';

            if (serviceSelect.value === 'Í∏∞ÌÉÄ') {
                otherServiceInputContainer.classList.remove('hidden');
                otherServiceInput.setAttribute('required', 'true');
            } else if (serviceSelect.value === 'Í∞úÏù∏ ÏãúÍ∞Ñ/Ìú¥Ïãù ÏãúÍ∞Ñ Ïû†Í∏à') {
                blockReasonInputContainer.classList.remove('hidden');
                // blockReasonInput is optional, so no 'required' attribute
            }
        });

        // Function to show booking management modal
        function showBookingManagementModal(type, slotTime, reservation = null) {
            bookingManagementModal.style.display = 'flex';
            currentSelectedSlotTime = slotTime;
            currentSelectedReservationId = reservation ? reservation.id : null;
            currentSelectedReservationStatus = reservation ? reservation.status : null;

            // Reset all forms/details and buttons
            newBookingOrBlockForm.classList.add('hidden');
            existingDetails.classList.add('hidden');
            markCompleteBtnModal.classList.add('hidden');
            unblockTimeBtnModal.classList.add('hidden');
            deleteReservationBtnModal.classList.add('hidden');
            confirmActionBtn.classList.remove('hidden');

            if (type === 'new') {
                bookingModalTitle.textContent = `${slotTime} ÏòàÏïΩ Ï∂îÍ∞Ä`;
                newBookingOrBlockForm.classList.remove('hidden');
                populateServiceSelect();
                serviceSelect.value = '';
                otherServiceInputContainer.classList.add('hidden');
                otherServiceInput.value = '';
                otherServiceInput.removeAttribute('required');
                blockReasonInputContainer.classList.add('hidden');
                blockReasonInput.value = '';
                confirmActionBtn.textContent = 'ÌôïÏù∏';
            } else if (type === 'existing') {
                bookingModalTitle.textContent = `${slotTime} ÏòàÏïΩ Í¥ÄÎ¶¨`;
                existingDetails.classList.remove('hidden');
                confirmActionBtn.classList.add('hidden');

                detailTime.textContent = reservation.time;
                detailStatus.textContent = '';

                let contentDisplay = '';
                if (reservation.status === 'blocked') {
                    contentDisplay = 'Í∞úÏù∏ ÏãúÍ∞Ñ/Ìú¥Ïãù ÏãúÍ∞Ñ';
                    if (reservation.customService) {
                        contentDisplay += ` (${reservation.customService})`;
                    }
                    detailStatus.textContent = 'Ïû†ÍπÄ';
                    unblockTimeBtnModal.classList.remove('hidden');
                    deleteReservationBtnModal.classList.remove('hidden');
                } else {
                    contentDisplay = reservation.service || 'ÏÑ†ÌÉù ÏïàÎê®';
                    if (reservation.service === 'Í∏∞ÌÉÄ' && reservation.customService) {
                        contentDisplay += `: ${reservation.customService}`;
                    }
                    detailStatus.textContent = reservation.status === 'completed' ? 'ÏôÑÎ£å' : 'ÏòàÏïΩÎê®';
                    if (reservation.status !== 'completed') {
                        markCompleteBtnModal.classList.remove('hidden');
                    }
                    deleteReservationBtnModal.classList.remove('hidden');
                }
                detailContent.textContent = contentDisplay;
            }
        }

        // Close booking management modal
        bookingModalCloseButton.onclick = () => {
            bookingManagementModal.style.display = 'none';
        };

        // Close booking management modal when clicking outside
        bookingManagementModal.addEventListener('click', (event) => {
            if (event.target === bookingManagementModal) {
                bookingManagementModal.style.display = 'none';
            }
        });

        // Authenticate user
        onAuthStateChanged(auth, async (user) => {
            console.log("onAuthStateChanged triggered. User:", user);
            if (user) {
                currentUserId = user.uid;
                userIdDisplay.textContent = currentUserId;
                console.log("Authenticated user ID:", currentUserId);
                const today = new Date();
                selectedDateInput.value = today.toISOString().split('T')[0];
                loadReservationsForSelectedDate(selectedDateInput.value);
            } else {
                try {
                    console.log("Attempting anonymous sign-in...");
                    await signInAnonymously(auth);
                    console.log("Anonymous sign-in successful (onAuthStateChanged will be triggered again with user data).");
                } catch (error) {
                    console.error("Firebase authentication error during anonymous sign-in:", error);
                    // ÏÇ¨Ïö©ÏûêÏóêÍ≤å Îçî Î™ÖÌôïÌïú ÏïàÎÇ¥Î•º Ï†úÍ≥µÌï©ÎãàÎã§.
                    showMessageModal("Ïù∏Ï¶ù Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: " + error.message + ". Firebase ÏΩòÏÜîÏóêÏÑú Îã§ÏùåÏùÑ ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî: 1. 'Authentication' > 'Sign-in method' ÌÉ≠ÏúºÎ°ú Ïù¥ÎèôÌïòÏó¨ 'Anonymous' Í≥µÍ∏âÏûêÎ•º ÌôúÏÑ±ÌôîÌñàÎäîÏßÄ. 2. 'Project settings' > 'Your apps'ÏóêÏÑú Ïõπ Ïï±Ïùò Firebase Íµ¨ÏÑ± Ï†ïÎ≥¥Í∞Ä ÏΩîÎìúÏôÄ ÏùºÏπòÌïòÎäîÏßÄ.", false, null, false); // Ïù¥ Î©îÏãúÏßÄÎäî ÏûêÎèô Îã´Ìûò ÏóÜÏù¥ Ïú†ÏßÄ
                    userIdDisplay.textContent = "Ïù∏Ï¶ù Ïã§Ìå®";
                }
            }
        });

        // Function to generate 30-minute time slots (10:00 to 19:00)
        function generateTimeSlots(startHour, endHour) {
            const slots = [];
            for (let h = startHour; h < endHour; h++) {
                for (let m = 0; m < 60; m += 30) {
                    const hour = String(h).padStart(2, '0');
                    const minute = String(m).padStart(2, '0');
                    slots.push(`${hour}:${minute}`);
                }
            }
            return slots;
        }

        // Function to render time slots
        function renderTimeSlots(allSlots, bookedReservationsMap) {
            timeSlotsDiv.innerHTML = '';
            const fragment = document.createDocumentFragment();
            const now = new Date(); // ÌòÑÏû¨ ÏãúÍ∞Ñ

            allSlots.forEach(slot => {
                const selectedDate = selectedDateInput.value;
                const [selectedYear, selectedMonth, selectedDay] = selectedDate.split('-').map(Number);
                const [selectedHour, selectedMinute] = slot.split(':').map(Number);
                const slotDateTime = new Date(selectedYear, selectedMonth - 1, selectedDay, selectedHour, selectedMinute);

                const existingReservation = bookedReservationsMap[slot];
                const isBookedOrBlocked = !!existingReservation;
                const isBlocked = isBookedOrBlocked && existingReservation.status === 'blocked';
                const isCompleted = isBookedOrBlocked && existingReservation.status === 'completed';
                const isPastSlot = slotDateTime < now; // Í≥ºÍ±∞ ÏãúÍ∞ÑÎåÄÏù∏ÏßÄ ÌôïÏù∏

                let slotClass = '';
                let statusText = '';
                let serviceText = '';

                if (isPastSlot) {
                    slotClass = 'past-slot';
                    statusText = 'ÏòàÏïΩÎ∂àÍ∞Ä';
                    serviceText = ''; // Í≥ºÍ±∞ ÏãúÍ∞ÑÎåÄÎäî ÏÑúÎπÑÏä§ ÎÇ¥Ïö© ÌëúÏãú ÏïàÌï®
                } else if (isBlocked) {
                    slotClass = 'blocked';
                    statusText = 'Ïû†ÍπÄ';
                    if (existingReservation.customService) {
                        serviceText = ` (${existingReservation.customService})`;
                    }
                } else if (isCompleted) {
                    slotClass = 'booked';
                    statusText = 'ÏôÑÎ£å';
                    serviceText = existingReservation.service ? ` (${existingReservation.service}` : '';
                    if (existingReservation.service === 'Í∏∞ÌÉÄ' && existingReservation.customService) {
                        serviceText += `: ${existingReservation.customService}`;
                    }
                    serviceText += ')';
                } else if (isBookedOrBlocked) {
                    slotClass = 'booked';
                    statusText = 'ÏòàÏïΩÎê®';
                    serviceText = existingReservation.service ? ` (${existingReservation.service}` : '';
                    if (existingReservation.service === 'Í∏∞ÌÉÄ' && existingReservation.customService) {
                        serviceText += `: ${existingReservation.customService}`;
                    }
                    serviceText += ')';
                } else {
                    slotClass = 'available';
                    statusText = 'ÏòàÏïΩ Í∞ÄÎä•';
                }

                const slotElement = document.createElement('div');
                slotElement.className = `time-slot-item p-3 rounded-lg text-sm font-medium flex justify-between items-center ${slotClass}`;
                slotElement.innerHTML = `
                    <span class="text-xl font-semibold">${slot}</span>
                    <span class="status-text text-base">${statusText}${serviceText}</span>
                `;
                fragment.appendChild(slotElement);

                // Add click listener to each time slot
                slotElement.onclick = () => {
                    if (isPastSlot) {
                        showMessageModal("ÏßÄÎÇòÍ∞Ñ ÏãúÍ∞ÑÏóêÎäî ÏòàÏïΩÌï† Ïàò ÏóÜÏäµÎãàÎã§.", false, null, false); // ÏûêÎèô Îã´Ìûò ÏóÜÏù¥ Ïú†ÏßÄ
                    } else if (isBookedOrBlocked) {
                        showBookingManagementModal('existing', slot, existingReservation);
                    } else {
                        showBookingManagementModal('new', slot);
                    }
                };
            });
            timeSlotsDiv.appendChild(fragment);

            if (allSlots.length === 0) {
                timeSlotsDiv.innerHTML = '<p class="text-gray-500 dark:text-gray-400 text-lg sm:col-span-2">ÎÇ†ÏßúÎ•º ÏÑ†ÌÉùÌïòÏó¨ ÏòàÏïΩ Í∞ÄÎä•Ìïú ÏãúÍ∞ÑÏùÑ ÌôïÏù∏ÌïòÏÑ∏Ïöî.</p>';
            }
        }

        // Load reservations for the selected date
        async function loadReservationsForSelectedDate(date) {
            if (!currentUserId) {
                console.warn("User not authenticated yet. Cannot load reservations.");
                return;
            }

            // Show loading indicator immediately
            timeSlotsDiv.innerHTML = '<p class="text-gray-500 dark:text-gray-400 text-lg sm:col-span-2">ÏòàÏïΩ ÌòÑÌô©ÏùÑ Î∂àÎü¨Ïò§Îäî Ï§ë...</p>';

            // Unsubscribe from previous listener if exists
            if (unsubscribe) {
                unsubscribe();
            }

            const reservationsRef = collection(db, `artifacts/${appId}/users/${currentUserId}/reservations`);
            const q = query(reservationsRef, where("date", "==", date));

            unsubscribe = onSnapshot(q, (snapshot) => {
                const reservations = [];
                const bookedReservationsMap = {};
                snapshot.forEach(doc => {
                    const data = doc.data();
                    const reservationWithId = { id: doc.id, ...data };
                    reservations.push(reservationWithId);
                    bookedReservationsMap[data.time] = reservationWithId;
                });

                // Sort reservations by time
                reservations.sort((a, b) => a.time.localeCompare(b.time));

                // Business hours: 10:00 to 19:00 (endHour is exclusive, so 19 means up to 18:30 slot)
                const allTimeSlots = generateTimeSlots(10, 19);
                renderTimeSlots(allTimeSlots, bookedReservationsMap);
            }, (error) => {
                console.error("Error fetching reservations:", error);
                showMessageModal("ÏòàÏïΩ Ï†ïÎ≥¥Î•º Î∂àÎü¨Ïò§Îäî Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: " + error.message, false, null, false); // Ïù¥ Î©îÏãúÏßÄÎäî ÏûêÎèô Îã´Ìûò ÏóÜÏù¥ Ïú†ÏßÄ
            });
        }

        // Event listener for date selection change
        selectedDateInput.addEventListener('change', (event) => {
            const newDate = event.target.value;
            if (newDate) {
                loadReservationsForSelectedDate(newDate);
            } else {
                timeSlotsDiv.innerHTML = '<p class="text-gray-500 dark:text-gray-400 text-lg sm:col-span-2">ÎÇ†ÏßúÎ•º ÏÑ†ÌÉùÌïòÏó¨ ÏòàÏïΩ Í∞ÄÎä•Ìïú ÏãúÍ∞ÑÏùÑ ÌôïÏù∏ÌïòÏÑ∏Ïöî.</p>';
            }
        });

        // Handle confirm action button click (for both new booking and blocking time)
        confirmActionBtn.addEventListener('click', async () => {
            // Always close the booking management modal when the confirm button is clicked
            bookingManagementModal.style.display = 'none';

            if (!currentUserId) {
                showMessageModal("ÏÇ¨Ïö©Ïûê Ïù∏Ï¶ùÏù¥ ÏôÑÎ£åÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§. Ïû†Ïãú ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî.", false, null, false); // ÏûêÎèô Îã´Ìûò ÏóÜÏù¥ Ïú†ÏßÄ
                return;
            }

            const selectedDate = selectedDateInput.value;
            const reservationTime = currentSelectedSlotTime;
            const selectedService = serviceSelect.value;
            let customService = '';

            if (!selectedDate || !reservationTime || !selectedService) {
                showMessageModal("ÎÇ†Ïßú, ÏãúÍ∞Ñ, Í∑∏Î¶¨Í≥† ÏÑúÎπÑÏä§Î•º ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.", false, null, false); // ÏûêÎèô Îã´Ìûò ÏóÜÏù¥ Ïú†ÏßÄ
                return;
            }

            // --- ÏãúÍ∞Ñ Í≤ÄÏ¶ù Î°úÏßÅ Ï∂îÍ∞Ä ---
            const now = new Date();
            const [selectedYear, selectedMonth, selectedDay] = selectedDate.split('-').map(Number);
            const [selectedHour, selectedMinute] = reservationTime.split(':').map(Number);

            const selectedDateTime = new Date(selectedYear, selectedMonth - 1, selectedDay, selectedHour, selectedMinute);

            if (selectedDateTime < now) {
                showMessageModal("ÏßÄÎÇòÍ∞Ñ ÏãúÍ∞ÑÏóêÎäî ÏòàÏïΩÌï† Ïàò ÏóÜÏäµÎãàÎã§.", false, null, false); // ÏûêÎèô Îã´Ìûò ÏóÜÏù¥ Ïú†ÏßÄ
                return;
            }
            // --- ÏãúÍ∞Ñ Í≤ÄÏ¶ù Î°úÏßÅ ÎÅù ---

            // Check for existing reservation at the same time slot
            const reservationsRef = collection(db, `artifacts/${appId}/users/${currentUserId}/reservations`);
            const q = query(reservationsRef,
                where("date", "==", selectedDate),
                where("time", "==", reservationTime)
            );
            const querySnapshot = await getDocs(q);

            if (!querySnapshot.empty) {
                showMessageModal("ÏÑ†ÌÉùÌïòÏã† ÏãúÍ∞ÑÏóê Ïù¥ÎØ∏ ÏòàÏïΩÏù¥ ÏûàÏäµÎãàÎã§. Îã§Î•∏ ÏãúÍ∞ÑÏùÑ ÏÑ†ÌÉùÌï¥Ï£ºÏÑ∏Ïöî.", false, null, false); // ÏûêÎèô Îã´Ìûò ÏóÜÏù¥ Ïú†ÏßÄ
                return;
            }

            try {
                const reservationData = {
                    date: selectedDate,
                    time: reservationTime,
                    createdAt: new Date().toISOString()
                };

                if (selectedService === 'Í∏∞ÌÉÄ') {
                    customService = otherServiceInput.value.trim();
                    if (!customService) {
                        showMessageModal("Í∏∞ÌÉÄ ÏÑúÎπÑÏä§ ÎÇ¥Ïö©ÏùÑ ÏûÖÎ†•Ìï¥Ï£ºÏÑ∏Ïöî.", false, null, false); // ÏûêÎèô Îã´Ìûò ÏóÜÏù¥ Ïú†ÏßÄ
                        return;
                    }
                    reservationData.service = selectedService;
                    reservationData.customService = customService;
                    reservationData.status = 'booked';
                } else if (selectedService === 'Í∞úÏù∏ ÏãúÍ∞Ñ/Ìú¥Ïãù ÏãúÍ∞Ñ Ïû†Í∏à') {
                    customService = blockReasonInput.value.trim();
                    reservationData.service = selectedService;
                    reservationData.customService = customService;
                    reservationData.status = 'blocked';
                } else {
                    reservationData.service = selectedService;
                    reservationData.status = 'booked';
                }

                await addDoc(reservationsRef, reservationData);
                showMessageModal("ÏûëÏóÖÏù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú Ï∂îÍ∞ÄÎêòÏóàÏäµÎãàÎã§!", false, null, true); // ÏÑ±Í≥µ Î©îÏãúÏßÄÎäî ÏûêÎèô Îã´Ìûò
            } catch (e) {
                console.error("Error adding document: ", e);
                showMessageModal("ÏûëÏóÖ Ï∂îÍ∞Ä Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: " + e.message, false, null, false); // ÏûêÎèô Îã´Ìûò ÏóÜÏù¥ Ïú†ÏßÄ
            }
        });

        // Mark reservation as complete from modal
        markCompleteBtnModal.addEventListener('click', async () => {
            if (!currentUserId || !currentSelectedReservationId) {
                showMessageModal("ÏÇ¨Ïö©Ïûê Ïù∏Ï¶ù ÎòêÎäî ÏòàÏïΩ Ï†ïÎ≥¥Í∞Ä Ïú†Ìö®ÌïòÏßÄ ÏïäÏäµÎãàÎã§.", false, null, false); // ÏûêÎèô Îã´Ìûò ÏóÜÏù¥ Ïú†ÏßÄ
                return;
            }
            showMessageModal('Ïù¥ ÏòàÏïΩÏùÑ ÏôÑÎ£å Ï≤òÎ¶¨ÌïòÏãúÍ≤†ÏäµÎãàÍπå?', true, async () => {
                try {
                    const reservationDocRef = doc(db, `artifacts/${appId}/users/${currentUserId}/reservations`, currentSelectedReservationId);
                    await updateDoc(reservationDocRef, {
                        status: 'completed'
                    });
                    bookingManagementModal.style.display = 'none'; // ÏòàÏïΩ Í¥ÄÎ¶¨ Î™®Îã¨ Î®ºÏ†Ä Îã´Í∏∞
                    showMessageModal("ÏòàÏïΩÏù¥ ÏôÑÎ£å Ï≤òÎ¶¨ÎêòÏóàÏäµÎãàÎã§!", false, null, true); // ÏÑ±Í≥µ Î©îÏãúÏßÄÎäî ÏûêÎèô Îã´Ìûò
                } catch (e) {
                    console.error("Error updating document: ", e);
                    showMessageModal("ÏòàÏïΩ ÏôÑÎ£å Ï≤òÎ¶¨ Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: " + e.message, false, null, false); // ÏûêÎèô Îã´Ìûò ÏóÜÏù¥ Ïú†ÏßÄ
                }
            });
        });

        // Unblock time from modal
        unblockTimeBtnModal.addEventListener('click', async () => {
            if (!currentUserId || !currentSelectedReservationId) {
                showMessageModal("ÏÇ¨Ïö©Ïûê Ïù∏Ï¶ù ÎòêÎäî Ïû†Í∏à Ï†ïÎ≥¥Í∞Ä Ïú†Ìö®ÌïòÏßÄ ÏïäÏäµÎãàÎã§.", false, null, false); // ÏûêÎèô Îã´Ìûò ÏóÜÏù¥ Ïú†ÏßÄ
                return;
            }
            showMessageModal('Ïù¥ ÏãúÍ∞Ñ Ïû†Í∏àÏùÑ Ìï¥Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?', true, async () => {
                try {
                    const reservationDocRef = doc(db, `artifacts/${appId}/users/${currentUserId}/reservations`, currentSelectedReservationId);
                    await deleteDoc(reservationDocRef);
                    bookingManagementModal.style.display = 'none'; // ÏòàÏïΩ Í¥ÄÎ¶¨ Î™®Îã¨ Î®ºÏ†Ä Îã´Í∏∞
                    showMessageModal("ÏãúÍ∞Ñ Ïû†Í∏àÏù¥ Ìï¥Ï†úÎêòÏóàÏäµÎãàÎã§!", false, null, true); // ÏÑ±Í≥µ Î©îÏãúÏßÄÎäî ÏûêÎèô Îã´Ìûò
                } catch (e) {
                    console.error("Error deleting document: ", e);
                    showMessageModal("ÏãúÍ∞Ñ Ïû†Í∏à Ìï¥Ï†ú Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: " + e.message, false, null, false); // ÏûêÎèô Îã´Ìûò ÏóÜÏù¥ Ïú†ÏßÄ
                }
            });
        });

        // Delete reservation/block from modal
        deleteReservationBtnModal.addEventListener('click', async () => {
            if (!currentUserId || !currentSelectedReservationId) {
                showMessageModal("ÏÇ¨Ïö©Ïûê Ïù∏Ï¶ù ÎòêÎäî Ï†ïÎ≥¥Í∞Ä Ïú†Ìö®ÌïòÏßÄ ÏïäÏäµÎãàÎã§.", false, null, false); // ÏûêÎèô Îã´Ìûò ÏóÜÏù¥ Ïú†ÏßÄ
                return;
            }
            let confirmMessage = '';
            if (currentSelectedReservationStatus === 'blocked') {
                confirmMessage = 'Ïù¥ ÏãúÍ∞Ñ Ïû†Í∏àÏùÑ Ï†ïÎßêÎ°ú ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?';
            } else {
                confirmMessage = 'Ïù¥ ÏòàÏïΩÏùÑ Ï†ïÎßêÎ°ú ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?';
            }

            showMessageModal(confirmMessage, true, async () => {
                try {
                    const reservationDocRef = doc(db, `artifacts/${appId}/users/${currentUserId}/reservations`, currentSelectedReservationId);
                    await deleteDoc(reservationDocRef);
                    bookingManagementModal.style.display = 'none'; // ÏòàÏïΩ Í¥ÄÎ¶¨ Î™®Îã¨ Î®ºÏ†Ä Îã´Í∏∞
                    showMessageModal("ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§!", false, null, true); // ÏÑ±Í≥µ Î©îÏãúÏßÄÎäî ÏûêÎèô Îã´Ìûò
                } catch (e) {
                    console.error("Error deleting document: ", e);
                    showMessageModal("ÏÇ≠Ï†ú Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§: " + e.message, false, null, false); // ÏûêÎèô Îã´Ìûò ÏóÜÏù¥ Ïú†ÏßÄ
                }
            });
        });

        // Set today's date as default on load
        window.onload = () => {
            const today = new Date();
            selectedDateInput.value = today.toISOString().split('T')[0];
            // loadReservationsForSelectedDate will be called once auth is ready
        };
    </script>
</body>
</html>
