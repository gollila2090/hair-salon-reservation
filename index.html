<!DOCTYPE html>
<html lang="ko" class="light"> <!-- Default to light mode -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì •ê¸°í™” í—¤ì–´ ì˜ˆì•½ ì‹œìŠ¤í…œ</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Base styles for light mode */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc; /* Very light blue-gray background */
        }
        /* .container custom CSS removed as replaced by Tailwind classes */
        .btn-primary {
            background-color: #8b5cf6; /* Violet 500 */
            color: white;
        }
        .btn-secondary {
            background-color: #e2e8f0; /* Slate 200 */
            color: #475569; /* Slate 700 */
        }
        .input-field {
            border-color: #cbd5e1; /* Slate 300 */
            background-color: #ffffff;
            color: #1f2937; /* Gray 800 */
        }
        .input-field:focus {
            border-color: #8b5cf6; /* Violet 500 on focus */
        }
        .time-slot-item.booked {
            background-color: #fef2f2; /* Red 50 */
            color: #dc2626; /* Red 600 */
            border-color: #fca5a5; /* Red 300 */
        }
        .time-slot-item.available {
            background-color: #ecfdf5; /* Green 50 */
            color: #10b981; /* Green 600 */
            border-color: #a7f3d0; /* Green 300 */
        }
        /* New style for blocked time slots */
        .time-slot-item.blocked {
            background-color: #f0f4f8; /* Light gray */
            color: #64748b; /* Slate 600 */
            border-color: #cbd5e1; /* Slate 300 */
            cursor: pointer; /* Still clickable to unblock */
        }
        .time-slot-item.blocked:hover {
            background-color: #e2e8f0; /* Slate 200 on hover */
        }
        /* Style for past time slots (updated color) */
        .time-slot-item.past-slot {
            background-color: #e0e0e0; /* Lighter grey for light mode */
            color: #616161; /* Darker grey text */
            border-color: #bdbdbd; /* Medium grey border */
            cursor: not-allowed; /* Indicate not clickable for booking */
            opacity: 0.7; /* Slightly dim past slots */
        }
        .time-slot-item.past-slot:hover {
            transform: none; /* No lift effect on past slots */
            box-shadow: none; /* No shadow change on past slots */
        }

        .modal-content {
            background-color: #fefefe;
        }
        .close-button {
            color: #94a3b8; /* Slate 400 */
        }

        /* Dark mode styles (applied when html has 'dark' class) */
        .dark body {
            background-color: #1a202c; /* Dark gray */
        }
        /* .dark .container custom CSS removed as replaced by Tailwind classes */
        .dark .btn-primary {
            background-color: #7c3aed; /* Violet 600 */
            color: white;
        }
        .dark .btn-primary:hover {
            background-color: #6d28d9; /* Violet 700 */
        }
        .dark .input-field {
            border-color: #475569; /* Slate 700 */
            background-color: #334155; /* Slate 800 */
            color: #e2e8f0; /* Light text */
        }
        .dark .input-field:focus {
            border-color: #a78bfa; /* Violet 400 on focus */
        }
        .dark .time-slot-item.booked {
            background-color: #450a0a; /* Red 950 */
            color: #fca5a5; /* Red 300 */
            border-color: #7f1d1d; /* Red 800 */
        }
        .dark .time-slot-item.available {
            background-color: #064e3b; /* Green 900 */
            color: #6ee7b7; /* Green 300 */
            border-color: #065f46; /* Green 800 */
        }
        /* New dark mode style for blocked time slots */
        .dark .time-slot-item.blocked {
            background-color: #334155; /* Slate 800 */
            color: #94a3b8; /* Slate 400 */
            border-color: #475569; /* Slate 700 */
        }
        .dark .time-slot-item.blocked:hover {
            background-color: #1e293b; /* Slate 900 on hover */
        }
        /* Dark mode style for past time slots (updated color) */
        .dark .time-slot-item.past-slot {
            background-color: #424242; /* Darker grey for dark mode */
            color: #9e9e9e; /* Lighter grey text */
            border-color: #616161; /* Medium grey border */
        }
        .dark .time-slot-item.past-slot:hover {
            transform: none;
            box-shadow: none;
        }

        /* Common styles (apply to both modes) */
        /* .container common CSS removed as replaced by Tailwind classes */
        .btn-primary {
            padding: 0.85rem 1.75rem; /* Increased padding for better touch target */
            border-radius: 0.75rem; /* More rounded buttons */
            font-weight: 600;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .btn-primary:hover {
            transform: translateY(-1px);
        }
        .btn-secondary {
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: 500;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        }
        .btn-secondary:hover {
            transform: translateY(-1px);
        }
        .input-field {
            padding: 0.85rem; /* Increased padding */
            border-width: 1px;
            border-radius: 0.75rem; /* More rounded */
            width: 100%;
            box-sizing: border-box;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }
        .time-slot-item {
            transition: background-color 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease;
            padding: 1.25rem; /* More padding for better touch experience */
            border-radius: 1rem; /* Even more rounded */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05), 0 2px 4px -1px rgba(0, 0, 0, 0.03); /* Subtle shadow for each slot */
        }
        .time-slot-item:hover {
            transform: translateY(-3px); /* More pronounced lift */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .time-slot-item .status-text {
            font-weight: 600; /* Make status text bolder */
        }

        .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 1000; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0,0,0,0.5); /* Darker overlay */
            justify-content: center;
            align-items: center;
            padding: 1rem; /* Padding for modal on small screens */
        }
        .modal-content {
            padding: 2.5rem; /* More padding */
            border-radius: 1.5rem; /* More rounded */
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25); /* Stronger shadow */
            width: 95%; /* Wider modal on mobile */
            max-width: 550px; /* Max width for larger screens */
            text-align: center;
            position: relative; /* For close button positioning */
        }
        .close-button {
            position: absolute;
            top: 1rem;
            right: 1.5rem;
            font-size: 2.25rem; /* Larger close button */
            font-weight: bold;
            cursor: pointer;
            transition: color 0.2s ease;
        }
        .close-button:hover,
        .close-button:focus {
            color: #475569; /* Slate 700 */
        }
        .modal-content h3 {
            margin-bottom: 1.5rem;
            font-size: 1.875rem; /* Larger modal title */
        }
        .modal-content p {
            margin-bottom: 1rem;
        }
    </style>
</head>
<body class="bg-f8fafc dark:bg-gray-900">
    <div class="max-w-4xl mx-auto p-6 md:p-8 lg:p-10 rounded-3xl shadow-xl bg-white dark:bg-gray-800 text-gray-800 dark:text-gray-100">
        <div class="flex justify-end mb-4">
            <button id="themeToggle" class="btn-secondary px-4 py-2 text-sm">
                <span id="themeIcon">ğŸŒ™</span> <span id="themeText">ë‹¤í¬ ëª¨ë“œ</span>
            </button>
        </div>

        <h1 class="text-5xl md:text-6xl font-extrabold text-center mb-8 bg-gradient-to-r from-purple-500 to-pink-500 text-transparent bg-clip-text tracking-tight">
            ì •ê¸°í™” í—¤ì–´ ì˜ˆì•½ ì‹œìŠ¤í…œ
        </h1>

        <div class="mb-8 p-5 bg-purple-50 border border-purple-200 rounded-xl text-purple-800 text-base shadow-sm dark:bg-purple-900 dark:border-purple-700 dark:text-purple-200">
            <p class="font-semibold">ì‚¬ìš©ì ID: <span id="userIdDisplay" class="font-normal text-purple-700 dark:text-purple-300">ë¡œë”© ì¤‘...</span></p>
            <p class="mt-3 text-sm text-purple-700 dark:text-purple-300">ì´ IDëŠ” ì•±ì˜ ë°ì´í„°ë¥¼ ê´€ë¦¬í•˜ëŠ” ë° ì‚¬ìš©ë©ë‹ˆë‹¤. ë‹¤ë¥¸ ì‚¬ìš©ìì™€ ì´ ì•±ì„ ê³µìœ í•˜ë ¤ë©´ ì´ IDë¥¼ ì•Œë ¤ì£¼ì„¸ìš”.</p>
        </div>

        <!-- Date Selection -->
        <div class="mb-8">
            <label for="selectedDate" class="block text-xl font-semibold mb-3">ë‚ ì§œ ì„ íƒ</label>
            <input type="date" id="selectedDate" class="input-field">
        </div>

        <!-- Reservation List and Time Slots -->
        <div class="grid grid-cols-1 gap-6 mb-8">
            <!-- Available Time Slots -->
            <div>
                <h2 class="text-xl font-semibold mb-5">ì˜ˆì•½ í˜„í™©</h2>
                <!-- Modified timeSlots div for 2 columns per row -->
                <div id="timeSlots" class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                    <!-- Time slots will be dynamically loaded here -->
                    <p class="text-gray-500 dark:text-gray-400 text-lg sm:col-span-2">ë‚ ì§œë¥¼ ì„ íƒí•˜ì—¬ ì˜ˆì•½ ê°€ëŠ¥í•œ ì‹œê°„ì„ í™•ì¸í•˜ì„¸ìš”.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Custom Message Modal -->
    <div id="messageModal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <p id="modalMessage" class="text-xl mb-6"></p>
            <button id="modalConfirmBtn" class="btn-primary mt-4 hidden">í™•ì¸</button>
        </div>
    </div>

    <!-- Booking Management Modal -->
    <div id="bookingManagementModal" class="modal">
        <div class="modal-content">
            <span class="close-button booking-modal-close">&times;</span>
            <h3 id="bookingModalTitle" class="text-3xl font-semibold mb-6"></h3>

            <!-- Form for New Booking / Blocking Time -->
            <div id="newBookingOrBlockForm" class="space-y-6 text-left">
                <p class="text-lg text-center">ì„ íƒí•˜ì‹  ì‹œê°„ëŒ€ì— ì˜ˆì•½ì„ ì¶”ê°€í•˜ì‹œê² ìŠµë‹ˆê¹Œ?</p>
                <div>
                    <label for="serviceSelect" class="block font-medium mb-2">ì„œë¹„ìŠ¤</label>
                    <select id="serviceSelect" class="input-field" required>
                        <!-- Options will be populated by JS -->
                    </select>
                </div>
                <!-- Input for 'ê¸°íƒ€' service -->
                <div id="otherServiceInputContainer" class="hidden">
                    <label for="otherServiceInput" class="block font-medium mb-2">ê¸°íƒ€ ì„œë¹„ìŠ¤ ë‚´ìš©:</label>
                    <input type="text" id="otherServiceInput" class="input-field" placeholder="ì˜ˆ: ë¶™ì„ë¨¸ë¦¬ ì œê±°">
                </div>
                <!-- Input for 'ê°œì¸ ì‹œê°„/íœ´ì‹ ì‹œê°„' reason -->
                <div id="blockReasonInputContainer" class="hidden">
                    <label for="blockReasonInput" class="block font-medium mb-2">ì ê¸ˆ ì‚¬ìœ  (ì„ íƒ ì‚¬í•­):</label>
                    <input type="text" id="blockReasonInput" class="input-field" placeholder="ì˜ˆ: ì ì‹¬ì‹œê°„, ì¬ë£Œ ì •ë¦¬">
                </div>
                <button id="confirmActionBtn" class="btn-primary w-full">í™•ì¸</button>
            </div>

            <!-- Details for Existing Booking / Blocked Time -->
            <div id="existingDetails" class="space-y-4 text-left">
                <p class="text-lg"><strong>ì‹œê°„:</strong> <span id="detailTime" class="font-semibold"></span></p>
                <p class="text-lg"><strong>ë‚´ìš©:</strong> <span id="detailContent" class="font-semibold"></span></p>
                <p class="text-lg"><strong>ìƒíƒœ:</strong> <span id="detailStatus" class="font-semibold"></span></p>
                <div class="flex flex-col sm:flex-row justify-center space-y-4 sm:space-y-0 sm:space-x-4 mt-8">
                    <button id="markCompleteBtnModal" class="btn-primary hidden">ì™„ë£Œ í‘œì‹œ</button>
                    <button id="unblockTimeBtnModal" class="btn-primary hidden">ì ê¸ˆ í•´ì œ</button>
                    <button id="deleteReservationBtnModal" class="btn-secondary hidden">ì‚­ì œ</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, addDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, where, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Firebase Configuration (Replitê³¼ ê°™ì€ ì™¸ë¶€ í™˜ê²½ì— ë°°í¬í•  ê²½ìš°, ì•„ë˜ ê°’ë“¤ì„ ì‹¤ì œ Firebase í”„ë¡œì íŠ¸ ì„¤ì •ìœ¼ë¡œ ëŒ€ì²´í•´ì•¼ í•©ë‹ˆë‹¤.)
        // 1. Firebase ì½˜ì†”(console.firebase.google.com)ì—ì„œ í”„ë¡œì íŠ¸ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
        // 2. í”„ë¡œì íŠ¸ ì„¤ì •ì—ì„œ 'ì›¹ ì•±'ì„ ì¶”ê°€í•˜ê³ , ì œê³µë˜ëŠ” êµ¬ì„± ê°ì²´ë¥¼ ë³µì‚¬í•©ë‹ˆë‹¤.
        // 3. ë³µì‚¬í•œ êµ¬ì„± ê°ì²´ ë‚´ì˜ 'apiKey', 'authDomain', 'projectId', 'storageBucket', 'messagingSenderId', 'appId' ê°’ì„
        //    ì•„ë˜ 'firebaseConfig' ê°ì²´ì— ì •í™•íˆ ë¶™ì—¬ë„£ìœ¼ì„¸ìš”.
        // 4. 'appId' ë³€ìˆ˜ëŠ” Firebase í”„ë¡œì íŠ¸ ID (firebaseConfig.projectId)ì™€ ë™ì¼í•˜ê²Œ ì„¤ì •í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤.
        const appId = 'hair-salon-reservation'; // ì‹¤ì œ Firebase Project IDë¡œ ë³€ê²½í•˜ì„¸ìš”.
        const firebaseConfig = {
            apiKey: "AIzaSyCjpIkmwKk3rXf89dsgqh2nvoAggHvdX_k", // ì‹¤ì œ Firebase API í‚¤ë¡œ ë³€ê²½í•˜ì„¸ìš”.
            authDomain: "hair-salon-reservation.firebaseapp.com", // ì‹¤ì œ Firebase Auth Domainìœ¼ë¡œ ë³€ê²½í•˜ì„¸ìš”.
            projectId: "hair-salon-reservation", // ì‹¤ì œ Firebase Project IDë¡œ ë³€ê²½í•˜ì„¸ìš”.
            storageBucket: "hair-salon-reservation.firebasestorage.app", // ì‹¤ì œ Firebase Storage Bucketìœ¼ë¡œ ë³€ê²½í•˜ì„¸ìš”.
            messagingSenderId: "898483539072", // ì‹¤ì œ Firebase Messaging Sender IDë¡œ ë³€ê²½í•˜ì„¸ìš”.
            appId: "1:898483539072:web:07b097beeccf63cdee6a65" // ì‹¤ì œ Firebase App IDë¡œ ë³€ê²½í•˜ì„¸ìš”. (firebaseConfig.projectIdì™€ ë™ì¼í•˜ê²Œ ì„¤ì •í•˜ëŠ” ê²ƒì´ ì¼ë°˜ì ì…ë‹ˆë‹¤.)
        };
        const initialAuthToken = null; // Replitê³¼ ê°™ì€ ì™¸ë¶€ í™˜ê²½ì—ì„œëŠ” initialAuthTokenì´ ì œê³µë˜ì§€ ì•Šìœ¼ë¯€ë¡œ ì´ ê°’ì€ nullë¡œ ìœ ì§€í•©ë‹ˆë‹¤.

        console.log("Firebase config:", firebaseConfig); // Firebase ì„¤ì • ë¡œê¹…
        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        console.log("Firebase app initialized:", app); // Firebase ì•± ì´ˆê¸°í™” ë¡œê¹…

        const db = getFirestore(app);
        const auth = getAuth(app);

        let currentUserId = null;
        let unsubscribe = null; // Stores the unsubscribe function for Firestore listener

        // DOM Elements
        const selectedDateInput = document.getElementById('selectedDate');
        const timeSlotsDiv = document.getElementById('timeSlots');
        const userIdDisplay = document.getElementById('userIdDisplay');

        // Theme Toggle Elements
        const themeToggle = document.getElementById('themeToggle');
        const themeIcon = document.getElementById('themeIcon');
        const themeText = document.getElementById('themeText');

        // Message Modal Elements
        const messageModal = document.getElementById('messageModal');
        const modalMessage = document.getElementById('modalMessage');
        const closeButton = document.querySelector('#messageModal .close-button');
        const modalConfirmBtn = document.getElementById('modalConfirmBtn');

        // Booking Management Modal Elements
        const bookingManagementModal = document.getElementById('bookingManagementModal');
        const bookingModalTitle = document.getElementById('bookingModalTitle');
        const newBookingOrBlockForm = document.getElementById('newBookingOrBlockForm');
        const existingDetails = document.getElementById('existingDetails');
        const serviceSelect = document.getElementById('serviceSelect');
        const otherServiceInputContainer = document.getElementById('otherServiceInputContainer');
        const otherServiceInput = document.getElementById('otherServiceInput');
        const blockReasonInputContainer = document.getElementById('blockReasonInputContainer');
        const blockReasonInput = document.getElementById('blockReasonInput');
        const confirmActionBtn = document.getElementById('confirmActionBtn');
        const markCompleteBtnModal = document.getElementById('markCompleteBtnModal');
        const unblockTimeBtnModal = document.getElementById('unblockTimeBtnModal');
        const deleteReservationBtnModal = document.getElementById('deleteReservationBtnModal');
        const bookingModalCloseButton = document.querySelector('#bookingManagementModal .booking-modal-close');

        // Detail elements for existing booking/block
        const detailTime = document.getElementById('detailTime');
        const detailContent = document.getElementById('detailContent');
        const detailStatus = document.getElementById('detailStatus');

        let currentSelectedSlotTime = null;
        let currentSelectedReservationId = null;
        let currentSelectedReservationStatus = null;

        // Define available services
        const availableServices = [
            'ë‚¨ì ì»·',
            'ì—¬ì ì»·',
            'ë‚¨ì íŒŒë§ˆ',
            'ì—¬ì íŒŒë§ˆ',
            'ì—¼ìƒ‰',
            'í´ë¦¬ë‹‰',
            'ê¸°íƒ€',
            'ê°œì¸ ì‹œê°„/íœ´ì‹ ì‹œê°„ ì ê¸ˆ'
        ];

        // Function to set theme
        function setTheme(theme) {
            if (theme === 'dark') {
                document.documentElement.classList.add('dark');
                themeIcon.textContent = 'â˜€ï¸';
                themeText.textContent = 'ë¼ì´íŠ¸ ëª¨ë“œ';
            } else {
                document.documentElement.classList.remove('dark');
                themeIcon.textContent = 'ğŸŒ™';
                themeText.textContent = 'ë‹¤í¬ ëª¨ë“œ';
            }
            localStorage.setItem('theme', theme);
        }

        // Load theme on page load
        const savedTheme = localStorage.getItem('theme') || 'light';
        setTheme(savedTheme);

        // Toggle theme on button click
        themeToggle.addEventListener('click', () => {
            const currentTheme = document.documentElement.classList.contains('dark') ? 'dark' : 'light';
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';
            setTheme(newTheme);
        });

        // Function to show custom message modal
        // autoHide: trueë©´ ì§§ì€ ì‹œê°„ í›„ ìë™ ë‹«í˜, falseë©´ ì‚¬ìš©ìê°€ ë‹«ì„ ë•Œê¹Œì§€ ìœ ì§€
        function showMessageModal(message, isConfirm = false, onConfirm = null, autoHide = true) {
            modalMessage.textContent = message;
            console.log(`[showMessageModal] Called with message: "${message}", isConfirm: ${isConfirm}, autoHide: ${autoHide}`); // Debug log

            if (isConfirm) {
                modalConfirmBtn.classList.remove('hidden');
                modalConfirmBtn.onclick = () => {
                    console.log("[showMessageModal] Confirm button clicked. Hiding modal.");
                    messageModal.style.display = 'none'; // Hide modal immediately
                    modalConfirmBtn.classList.add('hidden'); // Hide button
                    if (onConfirm) {
                        console.log("[showMessageModal] Executing onConfirm callback.");
                        onConfirm();
                    }
                };
                messageModal.style.display = 'flex'; // Show the modal
            } else {
                modalConfirmBtn.classList.add('hidden'); // Ensure confirm button is hidden
                modalConfirmBtn.onclick = null; // Clear any previous click handler
                messageModal.style.display = 'flex'; // Show the modal

                if (autoHide) {
                    console.log("[showMessageModal] Showing non-confirm message with auto-hide.");
                    setTimeout(() => {
                        console.log("[showMessageModal] Auto-hiding non-confirm message.");
                        messageModal.style.display = 'none'; // Auto-hide after 0.5 seconds
                    }, 500); // 0.5ì´ˆ í›„ ìë™ ë‹«ê¸°
                } else {
                    console.log("[showMessageModal] Showing non-confirm message without auto-hide.");
                    // Do nothing, modal stays until 'X' or outside click
                }
            }
        }

        // Function to hide message modal
        function hideMessageModal() {
            console.log("[hideMessageModal] Hiding message modal.");
            messageModal.style.display = 'none';
        }

        // Close message modal when close button is clicked
        closeButton.onclick = () => {
            hideMessageModal();
        };

        // Close message modal when clicking outside
        window.addEventListener('click', (event) => {
            if (event.target == messageModal) {
                hideMessageModal();
            }
        });

        // Function to populate service select dropdown
        function populateServiceSelect() {
            serviceSelect.innerHTML = '<option value="">ì„œë¹„ìŠ¤ë¥¼ ì„ íƒí•˜ì„¸ìš”</option>';
            availableServices.forEach(service => {
                const option = document.createElement('option');
                option.value = service;
                option.textContent = service;
                serviceSelect.appendChild(option);
            });
        }

        // Event listener for service select change to show/hide other service/block reason inputs
        serviceSelect.addEventListener('change', () => {
            otherServiceInputContainer.classList.add('hidden');
            otherServiceInput.removeAttribute('required');
            otherServiceInput.value = '';

            blockReasonInputContainer.classList.add('hidden');
            blockReasonInput.value = '';

            if (serviceSelect.value === 'ê¸°íƒ€') {
                otherServiceInputContainer.classList.remove('hidden');
                otherServiceInput.setAttribute('required', 'true');
            } else if (serviceSelect.value === 'ê°œì¸ ì‹œê°„/íœ´ì‹ ì‹œê°„ ì ê¸ˆ') {
                blockReasonInputContainer.classList.remove('hidden');
                // blockReasonInput is optional, so no 'required' attribute
            }
        });

        // Function to show booking management modal
        function showBookingManagementModal(type, slotTime, reservation = null) {
            bookingManagementModal.style.display = 'flex';
            currentSelectedSlotTime = slotTime;
            currentSelectedReservationId = reservation ? reservation.id : null;
            currentSelectedReservationStatus = reservation ? reservation.status : null;

            // Reset all forms/details and buttons
            newBookingOrBlockForm.classList.add('hidden');
            existingDetails.classList.add('hidden');
            markCompleteBtnModal.classList.add('hidden');
            unblockTimeBtnModal.classList.add('hidden');
            deleteReservationBtnModal.classList.add('hidden');
            confirmActionBtn.classList.remove('hidden');

            if (type === 'new') {
                bookingModalTitle.textContent = `${slotTime} ì˜ˆì•½ ì¶”ê°€`;
                newBookingOrBlockForm.classList.remove('hidden');
                populateServiceSelect();
                serviceSelect.value = '';
                otherServiceInputContainer.classList.add('hidden');
                otherServiceInput.value = '';
                otherServiceInput.removeAttribute('required');
                blockReasonInputContainer.classList.add('hidden');
                blockReasonInput.value = '';
                confirmActionBtn.textContent = 'í™•ì¸';
            } else if (type === 'existing') {
                bookingModalTitle.textContent = `${slotTime} ì˜ˆì•½ ê´€ë¦¬`;
                existingDetails.classList.remove('hidden');
                confirmActionBtn.classList.add('hidden');

                detailTime.textContent = reservation.time;
                detailStatus.textContent = '';

                let contentDisplay = '';
                if (reservation.status === 'blocked') {
                    contentDisplay = 'ê°œì¸ ì‹œê°„/íœ´ì‹ ì‹œê°„';
                    if (reservation.customService) {
                        contentDisplay += ` (${reservation.customService})`;
                    }
                    detailStatus.textContent = 'ì ê¹€';
                    unblockTimeBtnModal.classList.remove('hidden');
                    deleteReservationBtnModal.classList.remove('hidden');
                } else {
                    contentDisplay = reservation.service || 'ì„ íƒ ì•ˆë¨';
                    if (reservation.service === 'ê¸°íƒ€' && reservation.customService) {
                        contentDisplay += `: ${reservation.customService}`;
                    }
                    detailStatus.textContent = reservation.status === 'completed' ? 'ì™„ë£Œ' : 'ì˜ˆì•½ë¨';
                    if (reservation.status !== 'completed') {
                        markCompleteBtnModal.classList.remove('hidden');
                    }
                    deleteReservationBtnModal.classList.remove('hidden');
                }
                detailContent.textContent = contentDisplay;
            }
        }

        // Close booking management modal
        bookingModalCloseButton.onclick = () => {
            bookingManagementModal.style.display = 'none';
        };

        // Close booking management modal when clicking outside
        bookingManagementModal.addEventListener('click', (event) => {
            if (event.target === bookingManagementModal) {
                bookingManagementModal.style.display = 'none';
            }
        });

        // Authenticate user
        onAuthStateChanged(auth, async (user) => {
            console.log("onAuthStateChanged triggered. User:", user);
            if (user) {
                currentUserId = user.uid;
                userIdDisplay.textContent = currentUserId;
                console.log("Authenticated user ID:", currentUserId);
                const today = new Date();
                selectedDateInput.value = today.toISOString().split('T')[0];
                loadReservationsForSelectedDate(selectedDateInput.value);
            } else {
                try {
                    console.log("Attempting anonymous sign-in...");
                    await signInAnonymously(auth);
                    console.log("Anonymous sign-in successful (onAuthStateChanged will be triggered again with user data).");
                } catch (error) {
                    console.error("Firebase authentication error during anonymous sign-in:", error);
                    // ì‚¬ìš©ìì—ê²Œ ë” ëª…í™•í•œ ì•ˆë‚´ë¥¼ ì œê³µí•©ë‹ˆë‹¤.
                    showMessageModal("ì¸ì¦ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: " + error.message + ". Firebase ì½˜ì†”ì—ì„œ ë‹¤ìŒì„ í™•ì¸í•´ì£¼ì„¸ìš”: 1. 'Authentication' > 'Sign-in method' íƒ­ìœ¼ë¡œ ì´ë™í•˜ì—¬ 'Anonymous' ê³µê¸‰ìë¥¼ í™œì„±í™”í–ˆëŠ”ì§€. 2. 'Project settings' > 'Your apps'ì—ì„œ ì›¹ ì•±ì˜ Firebase êµ¬ì„± ì •ë³´ê°€ ì½”ë“œì™€ ì¼ì¹˜í•˜ëŠ”ì§€.", false, null, false); // ì´ ë©”ì‹œì§€ëŠ” ìë™ ë‹«í˜ ì—†ì´ ìœ ì§€
                    userIdDisplay.textContent = "ì¸ì¦ ì‹¤íŒ¨";
                }
            }
        });

        // Function to generate 30-minute time slots (10:00 to 19:00)
        function generateTimeSlots(startHour, endHour) {
            const slots = [];
            for (let h = startHour; h < endHour; h++) {
                for (let m = 0; m < 60; m += 30) {
                    const hour = String(h).padStart(2, '0');
                    const minute = String(m).padStart(2, '0');
                    slots.push(`${hour}:${minute}`);
                }
            }
            return slots;
        }

        // Function to render time slots
        function renderTimeSlots(allSlots, bookedReservationsMap) {
            timeSlotsDiv.innerHTML = '';
            const fragment = document.createDocumentFragment();
            const now = new Date(); // í˜„ì¬ ì‹œê°„

            allSlots.forEach(slot => {
                const selectedDate = selectedDateInput.value;
                const [selectedYear, selectedMonth, selectedDay] = selectedDate.split('-').map(Number);
                const [selectedHour, selectedMinute] = slot.split(':').map(Number);
                const slotDateTime = new Date(selectedYear, selectedMonth - 1, selectedDay, selectedHour, selectedMinute);

                const existingReservation = bookedReservationsMap[slot];
                const isBookedOrBlocked = !!existingReservation;
                const isBlocked = isBookedOrBlocked && existingReservation.status === 'blocked';
                const isCompleted = isBookedOrBlocked && existingReservation.status === 'completed';
                const isPastSlot = slotDateTime < now; // ê³¼ê±° ì‹œê°„ëŒ€ì¸ì§€ í™•ì¸

                let slotClass = '';
                let statusText = '';
                let serviceText = '';

                if (isPastSlot) {
                    slotClass = 'past-slot';
                    statusText = 'ì˜ˆì•½ë¶ˆê°€';
                    serviceText = ''; // ê³¼ê±° ì‹œê°„ëŒ€ëŠ” ì„œë¹„ìŠ¤ ë‚´ìš© í‘œì‹œ ì•ˆí•¨
                } else if (isBlocked) {
                    slotClass = 'blocked';
                    statusText = 'ì ê¹€';
                    if (existingReservation.customService) {
                        serviceText = ` (${existingReservation.customService})`;
                    }
                } else if (isCompleted) {
                    slotClass = 'booked';
                    statusText = 'ì™„ë£Œ';
                    serviceText = existingReservation.service ? ` (${existingReservation.service}` : '';
                    if (existingReservation.service === 'ê¸°íƒ€' && existingReservation.customService) {
                        serviceText += `: ${existingReservation.customService}`;
                    }
                    serviceText += ')';
                } else if (isBookedOrBlocked) {
                    slotClass = 'booked';
                    statusText = 'ì˜ˆì•½ë¨';
                    serviceText = existingReservation.service ? ` (${existingReservation.service}` : '';
                    if (existingReservation.service === 'ê¸°íƒ€' && existingReservation.customService) {
                        serviceText += `: ${existingReservation.customService}`;
                    }
                    serviceText += ')';
                } else {
                    slotClass = 'available';
                    statusText = 'ì˜ˆì•½ ê°€ëŠ¥';
                }

                const slotElement = document.createElement('div');
                slotElement.className = `time-slot-item p-3 rounded-lg text-sm font-medium flex justify-between items-center ${slotClass}`;
                slotElement.innerHTML = `
                    <span class="text-xl font-semibold">${slot}</span>
                    <span class="status-text text-base">${statusText}${serviceText}</span>
                `;
                fragment.appendChild(slotElement);

                // Add click listener to each time slot
                slotElement.onclick = () => {
                    if (isPastSlot) {
                        showMessageModal("ì§€ë‚˜ê°„ ì‹œê°„ì—ëŠ” ì˜ˆì•½í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.", false, null, false); // ìë™ ë‹«í˜ ì—†ì´ ìœ ì§€
                    } else if (isBookedOrBlocked) {
                        showBookingManagementModal('existing', slot, existingReservation);
                    } else {
                        showBookingManagementModal('new', slot);
                    }
                };
            });
            timeSlotsDiv.appendChild(fragment);

            if (allSlots.length === 0) {
                timeSlotsDiv.innerHTML = '<p class="text-gray-500 dark:text-gray-400 text-lg sm:col-span-2">ë‚ ì§œë¥¼ ì„ íƒí•˜ì—¬ ì˜ˆì•½ ê°€ëŠ¥í•œ ì‹œê°„ì„ í™•ì¸í•˜ì„¸ìš”.</p>';
            }
        }

        // Load reservations for the selected date
        async function loadReservationsForSelectedDate(date) {
            if (!currentUserId) {
                console.warn("User not authenticated yet. Cannot load reservations.");
                return;
            }

            // Show loading indicator immediately
            timeSlotsDiv.innerHTML = '<p class="text-gray-500 dark:text-gray-400 text-lg sm:col-span-2">ì˜ˆì•½ í˜„í™©ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</p>';

            // Unsubscribe from previous listener if exists
            if (unsubscribe) {
                unsubscribe();
            }

            const reservationsRef = collection(db, `artifacts/${appId}/users/${currentUserId}/reservations`);
            const q = query(reservationsRef, where("date", "==", date));

            unsubscribe = onSnapshot(q, (snapshot) => {
                const reservations = [];
                const bookedReservationsMap = {};
                snapshot.forEach(doc => {
                    const data = doc.data();
                    const reservationWithId = { id: doc.id, ...data };
                    reservations.push(reservationWithId);
                    bookedReservationsMap[data.time] = reservationWithId;
                });

                // Sort reservations by time
                reservations.sort((a, b) => a.time.localeCompare(b.time));

                // Business hours: 10:00 to 19:00 (endHour is exclusive, so 19 means up to 18:30 slot)
                const allTimeSlots = generateTimeSlots(10, 19);
                renderTimeSlots(allTimeSlots, bookedReservationsMap);
            }, (error) => {
                console.error("Error fetching reservations:", error);
                showMessageModal("ì˜ˆì•½ ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: " + error.message, false, null, false); // ì´ ë©”ì‹œì§€ëŠ” ìë™ ë‹«í˜ ì—†ì´ ìœ ì§€
            });
        }

        // Event listener for date selection change
        selectedDateInput.addEventListener('change', (event) => {
            const newDate = event.target.value;
            if (newDate) {
                loadReservationsForSelectedDate(newDate);
            } else {
                timeSlotsDiv.innerHTML = '<p class="text-gray-500 dark:text-gray-400 text-lg sm:col-span-2">ë‚ ì§œë¥¼ ì„ íƒí•˜ì—¬ ì˜ˆì•½ ê°€ëŠ¥í•œ ì‹œê°„ì„ í™•ì¸í•˜ì„¸ìš”.</p>';
            }
        });

        // Handle confirm action button click (for both new booking and blocking time)
        confirmActionBtn.addEventListener('click', async () => {
            // Always close the booking management modal when the confirm button is clicked
            bookingManagementModal.style.display = 'none';

            if (!currentUserId) {
                showMessageModal("ì‚¬ìš©ì ì¸ì¦ì´ ì™„ë£Œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.", false, null, false); // ìë™ ë‹«í˜ ì—†ì´ ìœ ì§€
                return;
            }

            const selectedDate = selectedDateInput.value;
            const reservationTime = currentSelectedSlotTime;
            const selectedService = serviceSelect.value;
            let customService = '';

            if (!selectedDate || !reservationTime || !selectedService) {
                showMessageModal("ë‚ ì§œ, ì‹œê°„, ê·¸ë¦¬ê³  ì„œë¹„ìŠ¤ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”.", false, null, false); // ìë™ ë‹«í˜ ì—†ì´ ìœ ì§€
                return;
            }

            // --- ì‹œê°„ ê²€ì¦ ë¡œì§ ì¶”ê°€ ---
            const now = new Date();
            const [selectedYear, selectedMonth, selectedDay] = selectedDate.split('-').map(Number);
            const [selectedHour, selectedMinute] = reservationTime.split(':').map(Number);

            const selectedDateTime = new Date(selectedYear, selectedMonth - 1, selectedDay, selectedHour, selectedMinute);

            if (selectedDateTime < now) {
                showMessageModal("ì§€ë‚˜ê°„ ì‹œê°„ì—ëŠ” ì˜ˆì•½í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.", false, null, false); // ìë™ ë‹«í˜ ì—†ì´ ìœ ì§€
                return;
            }
            // --- ì‹œê°„ ê²€ì¦ ë¡œì§ ë ---

            // Check for existing reservation at the same time slot
            const reservationsRef = collection(db, `artifacts/${appId}/users/${currentUserId}/reservations`);
            const q = query(reservationsRef,
                where("date", "==", selectedDate),
                where("time", "==", reservationTime)
            );
            const querySnapshot = await getDocs(q);

            if (!querySnapshot.empty) {
                showMessageModal("ì„ íƒí•˜ì‹  ì‹œê°„ì— ì´ë¯¸ ì˜ˆì•½ì´ ìˆìŠµë‹ˆë‹¤. ë‹¤ë¥¸ ì‹œê°„ì„ ì„ íƒí•´ì£¼ì„¸ìš”.", false, null, false); // ìë™ ë‹«í˜ ì—†ì´ ìœ ì§€
                return;
            }

            try {
                const reservationData = {
                    date: selectedDate,
                    time: reservationTime,
                    createdAt: new Date().toISOString()
                };

                if (selectedService === 'ê¸°íƒ€') {
                    customService = otherServiceInput.value.trim();
                    if (!customService) {
                        showMessageModal("ê¸°íƒ€ ì„œë¹„ìŠ¤ ë‚´ìš©ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.", false, null, false); // ìë™ ë‹«í˜ ì—†ì´ ìœ ì§€
                        return;
                    }
                    reservationData.service = selectedService;
                    reservationData.customService = customService;
                    reservationData.status = 'booked';
                } else if (selectedService === 'ê°œì¸ ì‹œê°„/íœ´ì‹ ì‹œê°„ ì ê¸ˆ') {
                    customService = blockReasonInput.value.trim();
                    reservationData.service = selectedService;
                    reservationData.customService = customService;
                    reservationData.status = 'blocked';
                } else {
                    reservationData.service = selectedService;
                    reservationData.status = 'booked';
                }

                await addDoc(reservationsRef, reservationData);
                showMessageModal("ì‘ì—…ì´ ì„±ê³µì ìœ¼ë¡œ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤!", false, null, true); // ì„±ê³µ ë©”ì‹œì§€ëŠ” ìë™ ë‹«í˜
            } catch (e) {
                console.error("Error adding document: ", e);
                showMessageModal("ì‘ì—… ì¶”ê°€ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: " + e.message, false, null, false); // ìë™ ë‹«í˜ ì—†ì´ ìœ ì§€
            }
        });

        // Mark reservation as complete from modal
        markCompleteBtnModal.addEventListener('click', async () => {
            if (!currentUserId || !currentSelectedReservationId) {
                showMessageModal("ì‚¬ìš©ì ì¸ì¦ ë˜ëŠ” ì˜ˆì•½ ì •ë³´ê°€ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.", false, null, false); // ìë™ ë‹«í˜ ì—†ì´ ìœ ì§€
                return;
            }
            showMessageModal('ì´ ì˜ˆì•½ì„ ì™„ë£Œ ì²˜ë¦¬í•˜ì‹œê² ìŠµë‹ˆê¹Œ?', true, async () => {
                try {
                    const reservationDocRef = doc(db, `artifacts/${appId}/users/${currentUserId}/reservations`, currentSelectedReservationId);
                    await updateDoc(reservationDocRef, {
                        status: 'completed'
                    });
                    bookingManagementModal.style.display = 'none'; // ì˜ˆì•½ ê´€ë¦¬ ëª¨ë‹¬ ë¨¼ì € ë‹«ê¸°
                    showMessageModal("ì˜ˆì•½ì´ ì™„ë£Œ ì²˜ë¦¬ë˜ì—ˆìŠµë‹ˆë‹¤!", false, null, true); // ì„±ê³µ ë©”ì‹œì§€ëŠ” ìë™ ë‹«í˜
                } catch (e) {
                    console.error("Error updating document: ", e);
                    showMessageModal("ì˜ˆì•½ ì™„ë£Œ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: " + e.message, false, null, false); // ìë™ ë‹«í˜ ì—†ì´ ìœ ì§€
                }
            });
        });

        // Unblock time from modal
        unblockTimeBtnModal.addEventListener('click', async () => {
            if (!currentUserId || !currentSelectedReservationId) {
                showMessageModal("ì‚¬ìš©ì ì¸ì¦ ë˜ëŠ” ì ê¸ˆ ì •ë³´ê°€ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.", false, null, false); // ìë™ ë‹«í˜ ì—†ì´ ìœ ì§€
                return;
            }
            showMessageModal('ì´ ì‹œê°„ ì ê¸ˆì„ í•´ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?', true, async () => {
                try {
                    const reservationDocRef = doc(db, `artifacts/${appId}/users/${currentUserId}/reservations`, currentSelectedReservationId);
                    await deleteDoc(reservationDocRef);
                    bookingManagementModal.style.display = 'none'; // ì˜ˆì•½ ê´€ë¦¬ ëª¨ë‹¬ ë¨¼ì € ë‹«ê¸°
                    showMessageModal("ì‹œê°„ ì ê¸ˆì´ í•´ì œë˜ì—ˆìŠµë‹ˆë‹¤!", false, null, true); // ì„±ê³µ ë©”ì‹œì§€ëŠ” ìë™ ë‹«í˜
                } catch (e) {
                    console.error("Error deleting document: ", e);
                    showMessageModal("ì‹œê°„ ì ê¸ˆ í•´ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: " + e.message, false, null, false); // ìë™ ë‹«í˜ ì—†ì´ ìœ ì§€
                }
            });
        });

        // Delete reservation/block from modal
        deleteReservationBtnModal.addEventListener('click', async () => {
            if (!currentUserId || !currentSelectedReservationId) {
                showMessageModal("ì‚¬ìš©ì ì¸ì¦ ë˜ëŠ” ì •ë³´ê°€ ìœ íš¨í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.", false, null, false); // ìë™ ë‹«í˜ ì—†ì´ ìœ ì§€
                return;
            }
            let confirmMessage = '';
            if (currentSelectedReservationStatus === 'blocked') {
                confirmMessage = 'ì´ ì‹œê°„ ì ê¸ˆì„ ì •ë§ë¡œ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?';
            } else {
                confirmMessage = 'ì´ ì˜ˆì•½ì„ ì •ë§ë¡œ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?';
            }

            showMessageModal(confirmMessage, true, async () => {
                try {
                    const reservationDocRef = doc(db, `artifacts/${appId}/users/${currentUserId}/reservations`, currentSelectedReservationId);
                    await deleteDoc(reservationDocRef);
                    bookingManagementModal.style.display = 'none'; // ì˜ˆì•½ ê´€ë¦¬ ëª¨ë‹¬ ë¨¼ì € ë‹«ê¸°
                    showMessageModal("ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤!", false, null, true); // ì„±ê³µ ë©”ì‹œì§€ëŠ” ìë™ ë‹«í˜
                } catch (e) {
                    console.error("Error deleting document: ", e);
                    showMessageModal("ì‚­ì œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: " + e.message, false, null, false); // ìë™ ë‹«í˜ ì—†ì´ ìœ ì§€
                }
            });
        });

        // Set today's date as default on load
        window.onload = () => {
            const today = new Date();
            selectedDateInput.value = today.toISOString().split('T')[0];
            // loadReservationsForSelectedDate will be called once auth is ready
        };
    </script>
</body>
</html>
