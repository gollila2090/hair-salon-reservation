<!DOCTYPE html>
<html lang="ko" class="light"> <!-- Default to light mode -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>정기화 헤어 예약 시스템</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Inter Font -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Base styles for light mode */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc; /* Very light blue-gray background */
        }
        /* .container custom CSS removed as replaced by Tailwind classes */
        .btn-primary {
            background-color: #8b5cf6; /* Violet 500 */
            color: white;
        }
        .btn-secondary {
            background-color: #e2e8f0; /* Slate 200 */
            color: #475569; /* Slate 700 */
        }
        .input-field {
            border-color: #cbd5e1; /* Slate 300 */
            background-color: #ffffff;
            color: #1f2937; /* Gray 800 */
        }
        .input-field:focus {
            border-color: #8b5cf6; /* Violet 500 on focus */
        }
        .time-slot-item.booked {
            background-color: #fef2f2; /* Red 50 */
            color: #dc2626; /* Red 600 */
            border-color: #fca5a5; /* Red 300 */
        }
        .time-slot-item.available {
            background-color: #ecfdf5; /* Green 50 */
            color: #10b981; /* Green 600 */
            border-color: #a7f3d0; /* Green 300 */
        }
        /* New style for blocked time slots */
        .time-slot-item.blocked {
            background-color: #f0f4f8; /* Light gray */
            color: #64748b; /* Slate 600 */
            border-color: #cbd5e1; /* Slate 300 */
            cursor: pointer; /* Still clickable to unblock */
        }
        .time-slot-item.blocked:hover {
            background-color: #e2e8f0; /* Slate 200 on hover */
        }
        /* Style for past time slots (updated color) */
        .time-slot-item.past-slot {
            background-color: #e0e0e0; /* Lighter grey for light mode */
            color: #616161; /* Darker grey text */
            border-color: #bdbdbd; /* Medium grey border */
            cursor: not-allowed; /* Indicate not clickable for booking */
            opacity: 0.7; /* Slightly dim past slots */
        }
        .time-slot-item.past-slot:hover {
            transform: none; /* No lift effect on past slots */
            box-shadow: none; /* No shadow change on past slots */
        }
        /* Style for completed time slots (NEW) */
        .time-slot-item.completed {
            background-color: #e0f2fe; /* Light blue 50 */
            color: #0284c7; /* Sky 600 */
            border-color: #7dd3fc; /* Sky 300 */
        }
        .time-slot-item.completed:hover {
            transform: translateY(-3px); /* Retain lift effect */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }

        .modal-content {
            background-color: #fefefe;
        }
        .close-button {
            color: #94a3b8; /* Slate 400 */
        }

        /* Dark mode styles (applied when html has 'dark' class) */
        .dark body {
            background-color: #1a202c; /* Dark gray */
        }
        /* .dark .container custom CSS removed as replaced by Tailwind classes */
        .dark .btn-primary {
            background-color: #7c3aed; /* Violet 600 */
            color: white;
        }
        .dark .btn-primary:hover {
            background-color: #6d28d9; /* Violet 700 */
        }
        .dark .input-field {
            border-color: #475569; /* Slate 700 */
            background-color: #334155; /* Slate 800 */
            color: #e2e8f0; /* Light text */
        }
        .dark .input-field:focus {
            border-color: #a78bfa; /* Violet 400 on focus */
        }
        .dark .time-slot-item.booked {
            background-color: #450a0a; /* Red 950 */
            color: #fca5a5; /* Red 300 */
            border-color: #7f1d1d; /* Red 800 */
        }
        .dark .time-slot-item.available {
            background-color: #064e3b; /* Green 900 */
            color: #6ee7b7; /* Green 300 */
            border-color: #065f46; /* Green 800 */
        }
        /* New dark mode style for blocked time slots */
        .dark .time-slot-item.blocked {
            background-color: #334155; /* Slate 800 */
            color: #94a3b8; /* Slate 400 */
            border-color: #475569; /* Slate 700 */
        }
        .dark .time-slot-item.blocked:hover {
            background-color: #1e293b; /* Slate 900 on hover */
        }
        /* Dark mode style for past time slots (updated color) */
        .dark .time-slot-item.past-slot {
            background-color: #424242; /* Darker grey for dark mode */
            color: #9e9e9e; /* Lighter grey text */
            border-color: #616161; /* Medium grey border */
        }
        .dark .time-slot-item.past-slot:hover {
            transform: none;
            box-shadow: none;
        }
        /* Dark mode style for completed time slots (NEW) */
        .dark .time-slot-item.completed {
            background-color: #0c4a6e; /* Dark blue 900 */
            color: #7dd3fc; /* Sky 300 */
            border-color: #0369a1; /* Sky 700 */
        }
        .dark .time-slot-item.completed:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }

        /* Common styles (apply to both modes) */
        /* .container common CSS removed as replaced by Tailwind classes */
        .btn-primary {
            padding: 0.85rem 1.75rem; /* Increased padding for better touch target */
            border-radius: 0.75rem; /* More rounded buttons */
            font-weight: 600;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
        .btn-primary:hover {
            transform: translateY(-1px);
        }
        .btn-secondary {
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: 500;
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        }
        .btn-secondary:hover {
            transform: translateY(-1px);
        }
        .input-field {
            padding: 0.85rem; /* Increased padding */
            border-width: 1px;
            border-radius: 0.75rem; /* More rounded */
            width: 100%;
            box-sizing: border-box;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }
        .time-slot-item {
            transition: background-color 0.2s ease, transform 0.1s ease, box-shadow 0.2s ease;
            padding: 1.25rem; /* More padding for better touch experience */
            border-radius: 1rem; /* Even more rounded */
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.05), 0 2px 4px -1px rgba(0, 0, 0, 0.03); /* Subtle shadow for each slot */
        }
        .time-slot-item:hover {
            transform: translateY(-3px); /* More pronounced lift */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        .time-slot-item .status-text {
            font-weight: 600; /* Make status text bolder */
        }

        .modal {
            display: none; /* Hidden by default */
            position: fixed; /* Stay in place */
            z-index: 1000; /* Sit on top */
            left: 0;
            top: 0;
            width: 100%; /* Full width */
            height: 100%; /* Full height */
            overflow: auto; /* Enable scroll if needed */
            background-color: rgba(0,0,0,0.5); /* Darker overlay */
            justify-content: center;
            align-items: center;
            padding: 1rem; /* Padding for modal on small screens */
        }
        .modal-content {
            padding: 2.5rem; /* More padding */
            border-radius: 1.5rem; /* More rounded */
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25); /* Stronger shadow */
            width: 95%; /* Wider modal on mobile */
            max-width: 550px; /* Max width for larger screens */
            text-align: center;
            position: relative; /* For close button positioning */
        }
        .close-button {
            position: absolute;
            top: 1rem;
            right: 1.5rem;
            font-size: 2.25rem; /* Larger close button */
            font-weight: bold;
            cursor: pointer;
            transition: color 0.2s ease;
        }
        .close-button:hover,
        .close-button:focus {
            color: #475569; /* Slate 700 */
        }
        .modal-content h3 {
            margin-bottom: 1.5rem;
            font-size: 1.875rem; /* Larger modal title */
        }
        .modal-content p {
            margin-bottom: 1rem;
        }

        /* Spinner CSS */
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #8b5cf6; /* Violet 500 */
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            display: inline-block;
            vertical-align: middle;
            margin-right: 8px;
        }
        .dark .spinner {
            border: 4px solid rgba(255, 255, 255, 0.2);
            border-left-color: #a78bfa; /* Violet 400 */
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-f8fafc dark:bg-gray-900">
    <div class="max-w-4xl mx-auto p-6 md:p-8 lg:p-10 rounded-3xl shadow-xl bg-white dark:bg-gray-800 text-gray-800 dark:text-gray-100">
        <div class="flex justify-end mb-4">
            <button id="themeToggle" class="btn-secondary px-4 py-2 text-sm">
                <span id="themeIcon">🌙</span> <span id="themeText">다크 모드</span>
            </button>
        </div>

        <h1 class="text-3xl sm:text-4xl md:text-5xl lg:text-6xl font-extrabold text-center mb-8 bg-gradient-to-r from-purple-500 to-pink-500 text-transparent bg-clip-text tracking-tight">
            정기화 헤어 예약 시스템
        </h1>

        <div class="mb-8 p-5 bg-purple-50 border border-purple-200 rounded-xl text-purple-800 text-base shadow-sm dark:bg-purple-900 dark:border-purple-700 dark:text-purple-200">
            <p class="font-semibold text-sm sm:text-base">사용자 ID: <span id="userIdDisplay" class="font-normal text-purple-700 dark:text-purple-300">로딩 중...</span></p>
            <p class="mt-3 text-xs sm:text-sm text-purple-700 dark:text-purple-300">이 ID는 앱의 데이터를 관리하는 데 사용됩니다. 다른 사용자와 이 앱을 공유하려면 이 ID를 알려주세요.</p>
        </div>

        <!-- Date Selection -->
        <div class="mb-8">
            <label for="selectedDate" class="block text-xl sm:text-2xl font-semibold mb-3">날짜 선택</label>
            <input type="date" id="selectedDate" class="input-field">
        </div>

        <!-- Reservation List and Time Slots -->
        <div class="grid grid-cols-1 gap-6 mb-8">
            <!-- Available Time Slots -->
            <div>
                <h2 class="text-xl sm:text-2xl font-semibold mb-5">예약 현황</h2>
                <!-- Loading Message and Spinner -->
                <p id="loadingMessage" class="text-sm sm:text-base text-gray-500 dark:text-gray-400 sm:col-span-2 flex items-center justify-center mb-4" style="display: none;">
                    <span class="spinner"></span> 예약 현황을 불러오는 중...
                </p>
                <div id="timeSlots" class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                    <!-- Time slots will be dynamically loaded here -->
                </div>
            </div>
        </div>

        <!-- Creator Information -->
        <div class="text-center mt-10 text-gray-500 dark:text-gray-400 text-sm">
            <p>by made 아빠고릴라</p>
        </div>
    </div>

    <!-- Custom Message Modal - REMOVED -->
    <!-- <div id="messageModal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <p id="modalMessage" class="text-base sm:text-xl mb-6"></p>
            <button id="modalConfirmBtn" class="btn-primary mt-4 hidden">확인</button>
        </div>
    </div> -->

    <!-- Booking Management Modal -->
    <div id="bookingManagementModal" class="modal">
        <div class="modal-content">
            <span class="close-button booking-modal-close">&times;</span>
            <h3 id="bookingModalTitle" class="text-xl sm:text-3xl font-semibold mb-6"></h3>

            <!-- Form for New Booking / Blocking Time -->
            <div id="newBookingOrBlockForm" class="space-y-6 text-left">
                <p class="text-sm sm:text-lg text-center">선택하신 시간대에 예약을 추가하시겠습니까?</p>
                <div>
                    <label for="serviceSelect" class="block font-medium mb-2 text-sm sm:text-base">서비스</label>
                    <select id="serviceSelect" class="input-field" required>
                        <!-- Options will be populated by JS -->
                    </select>
                </div>
                <!-- Input for '기타' service -->
                <div id="otherServiceInputContainer" class="hidden">
                    <label for="otherServiceInput" class="block font-medium mb-2 text-sm sm:text-base">기타 서비스 내용:</label>
                    <input type="text" id="otherServiceInput" class="input-field" placeholder="예: 붙임머리 제거">
                </div>
                <!-- Input for '개인 시간/휴식 시간' reason -->
                <div id="blockReasonInputContainer" class="hidden">
                    <label for="blockReasonInput" class="block font-medium mb-2 text-sm sm:text-base">잠금 사유 (선택 사항):</label>
                    <input type="text" id="blockReasonInput" class="input-field" placeholder="예: 점심시간, 재료 정리">
                </div>
                <button id="confirmActionBtn" class="btn-primary w-full">확인</button>
            </div>

            <!-- Details for Existing Booking / Blocked Time -->
            <div id="existingDetails" class="space-y-4 text-left">
                <p class="text-sm sm:text-lg"><strong>시간:</strong> <span id="detailTime" class="font-semibold"></span></p>
                <p class="text-sm sm:text-lg"><strong>내용:</strong> <span id="detailContent" class="font-semibold"></span></p>
                <p class="text-sm sm:text-lg"><strong>상태:</strong> <span id="detailStatus" class="font-semibold"></span></p>
                <div class="flex flex-col sm:flex-row justify-center space-y-4 sm:space-y-0 sm:space-x-4 mt-8">
                    <button id="markCompleteBtnModal" class="btn-primary hidden">완료 표시</button>
                    <button id="unblockTimeBtnModal" class="btn-primary hidden">잠금 해제</button>
                    <button id="deleteReservationBtnModal" class="btn-secondary hidden">삭제</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, addDoc, setDoc, updateDoc, deleteDoc, onSnapshot, collection, query, where, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Firebase Configuration (Replit과 같은 외부 환경에 배포할 경우, 아래 값들을 실제 Firebase 프로젝트 설정으로 대체해야 합니다.)
        // 1. Firebase 콘솔(console.firebase.google.com)에서 프로젝트를 생성합니다.
        // 2. 프로젝트 설정에서 '웹 앱'을 추가하고, 제공되는 구성 객체를 복사합니다.
        // 3. 복사한 구성 객체 내의 'apiKey', 'authDomain', 'projectId', 'storageBucket', 'messagingSenderId', 'appId' 값을
        //    아래 'firebaseConfig' 객체에 정확히 붙여넣으세요.
        // 4. 'appId' 변수는 Firebase 프로젝트 ID (firebaseConfig.projectId)와 동일하게 설정하는 것이 좋습니다.
        const appId = 'hair-salon-reservation'; // 실제 Firebase Project ID로 변경하세요.
        const firebaseConfig = {
            apiKey: "AIzaSyCjpIkmwKk3rXf89dsgqh2nvoAggHvdX_k", // 실제 Firebase API 키로 변경하세요.
            authDomain: "hair-salon-reservation.firebaseapp.com", // 실제 Firebase Auth Domain으로 변경하세요.
            projectId: "hair-salon-reservation", // 실제 Firebase Project ID로 변경하세요.
            storageBucket: "hair-salon-reservation.firebasestorage.app", // 실제 Firebase Storage Bucket으로 변경하세요.
            messagingSenderId: "898483539072", // 실제 Firebase Messaging Sender ID로 변경하세요.
            appId: "1:898483539072:web:07b097beeccf63cdee6a65" // 실제 Firebase App ID로 변경하세요. (firebaseConfig.projectId와 동일하게 설정하는 것이 일반적입니다.)
        };
        const initialAuthToken = null; // Replit과 같은 외부 환경에서는 initialAuthToken이 제공되지 않으므로 이 값은 null로 유지합니다.

        console.log("Firebase config:", firebaseConfig); // Firebase 설정 로깅
        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        console.log("Firebase app initialized:", app); // Firebase 앱 초기화 로깅

        const db = getFirestore(app);
        const auth = getAuth(app);

        let currentUserId = null;
        let unsubscribe = null; // Stores the unsubscribe function for Firestore listener

        // DOM Elements
        const selectedDateInput = document.getElementById('selectedDate');
        const timeSlotsDiv = document.getElementById('timeSlots');
        const userIdDisplay = document.getElementById('userIdDisplay');
        const loadingMessage = document.getElementById('loadingMessage'); // Get the loading message element

        // Theme Toggle Elements
        const themeToggle = document.getElementById('themeToggle');
        const themeIcon = document.getElementById('themeIcon');
        const themeText = document.getElementById('themeText');

        // Booking Management Modal Elements
        const bookingManagementModal = document.getElementById('bookingManagementModal');
        const bookingModalTitle = document.getElementById('bookingModalTitle');
        const newBookingOrBlockForm = document.getElementById('newBookingOrBlockForm');
        const existingDetails = document.getElementById('existingDetails');
        const serviceSelect = document.getElementById('serviceSelect');
        const otherServiceInputContainer = document.getElementById('otherServiceInputContainer');
        const otherServiceInput = document.getElementById('otherServiceInput');
        const blockReasonInputContainer = document.getElementById('blockReasonInputContainer');
        const blockReasonInput = document.getElementById('blockReasonInput');
        const confirmActionBtn = document.getElementById('confirmActionBtn');
        const markCompleteBtnModal = document.getElementById('markCompleteBtnModal');
        const unblockTimeBtnModal = document.getElementById('unblockTimeBtnModal');
        const deleteReservationBtnModal = document.getElementById('deleteReservationBtnModal');
        const bookingModalCloseButton = document.querySelector('#bookingManagementModal .booking-modal-close');

        // Detail elements for existing booking/block
        const detailTime = document.getElementById('detailTime');
        const detailContent = document.getElementById('detailContent');
        const detailStatus = document.getElementById('detailStatus');

        let currentSelectedSlotTime = null;
        let currentSelectedReservationId = null;
        let currentSelectedReservationStatus = null;

        // Define available services
        const availableServices = [
            '남자 컷',
            '여자 컷',
            '남자 파마',
            '여자 파마',
            '염색',
            '클리닉',
            '기타',
            '개인 시간/휴식 시간 잠금'
        ];

        // Function to set theme
        function setTheme(theme) {
            if (theme === 'dark') {
                document.documentElement.classList.add('dark');
                themeIcon.textContent = '☀️';
                themeText.textContent = '라이트 모드';
            } else {
                document.documentElement.classList.remove('dark');
                themeIcon.textContent = '🌙';
                themeText.textContent = '다크 모드';
            }
            localStorage.setItem('theme', theme);
        }

        // Load theme on page load
        const savedTheme = localStorage.getItem('theme') || 'light';
        setTheme(savedTheme);

        // Toggle theme on button click
        themeToggle.addEventListener('click', () => {
            const currentTheme = document.documentElement.classList.contains('dark') ? 'dark' : 'light';
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';
            setTheme(newTheme);
        });

        // Function to populate service select dropdown
        function populateServiceSelect() {
            serviceSelect.innerHTML = '<option value="">서비스를 선택하세요</option>';
            availableServices.forEach(service => {
                const option = document.createElement('option');
                option.value = service;
                option.textContent = service;
                serviceSelect.appendChild(option);
            });
        }

        // Event listener for service select change to show/hide other service/block reason inputs
        serviceSelect.addEventListener('change', () => {
            otherServiceInputContainer.classList.add('hidden');
            otherServiceInput.removeAttribute('required');
            otherServiceInput.value = '';

            blockReasonInputContainer.classList.add('hidden');
            blockReasonInput.value = '';

            if (serviceSelect.value === '기타') {
                otherServiceInputContainer.classList.remove('hidden');
                otherServiceInput.setAttribute('required', 'true');
            } else if (serviceSelect.value === '개인 시간/휴식 시간 잠금') {
                blockReasonInputContainer.classList.remove('hidden');
                // blockReasonInput is optional, so no 'required' attribute
            }
        });

        // Function to show booking management modal
        function showBookingManagementModal(type, slotTime, reservation = null) {
            bookingManagementModal.style.display = 'flex';
            currentSelectedSlotTime = slotTime;
            currentSelectedReservationId = reservation ? reservation.id : null;
            currentSelectedReservationStatus = reservation ? reservation.status : null;

            // Reset all forms/details and buttons
            newBookingOrBlockForm.classList.add('hidden');
            existingDetails.classList.add('hidden');
            markCompleteBtnModal.classList.add('hidden');
            unblockTimeBtnModal.classList.add('hidden');
            deleteReservationBtnModal.classList.add('hidden');
            confirmActionBtn.classList.remove('hidden');

            if (type === 'new') {
                bookingModalTitle.textContent = `${slotTime} 예약 추가`;
                newBookingOrBlockForm.classList.remove('hidden');
                populateServiceSelect();
                serviceSelect.value = '';
                otherServiceInputContainer.classList.add('hidden');
                otherServiceInput.value = '';
                otherServiceInput.removeAttribute('required');
                blockReasonInputContainer.classList.add('hidden');
                blockReasonInput.value = '';
                confirmActionBtn.textContent = '확인';
            } else if (type === 'existing') {
                bookingModalTitle.textContent = `${slotTime} 예약 관리`;
                existingDetails.classList.remove('hidden');
                confirmActionBtn.classList.add('hidden');

                detailTime.textContent = reservation.time;
                detailStatus.textContent = '';

                let contentDisplay = '';
                if (reservation.status === 'blocked') {
                    contentDisplay = '개인 시간/휴식 시간';
                    if (reservation.customService) {
                        contentDisplay += ` (${reservation.customService})`;
                    }
                    detailStatus.textContent = '잠김';
                    unblockTimeBtnModal.classList.remove('hidden');
                    deleteReservationBtnModal.classList.remove('hidden');
                } else {
                    contentDisplay = reservation.service || '선택 안됨';
                    if (reservation.service === '기타' && reservation.customService) {
                        contentDisplay += `: ${existingReservation.customService}`;
                    }
                    detailStatus.textContent = reservation.status === 'completed' ? '완료' : '예약됨';
                    if (reservation.status !== 'completed') {
                        markCompleteBtnModal.classList.remove('hidden');
                    }
                    deleteReservationBtnModal.classList.remove('hidden');
                }
                detailContent.textContent = contentDisplay;
            }
        }

        // Close booking management modal
        bookingModalCloseButton.onclick = () => {
            bookingManagementModal.style.display = 'none';
        };

        // Close booking management modal when clicking outside
        bookingManagementModal.addEventListener('click', (event) => {
            if (event.target === bookingManagementModal) {
                bookingManagementModal.style.display = 'none';
            }
        });

        // Authenticate user
        onAuthStateChanged(auth, async (user) => {
            console.log("onAuthStateChanged triggered. User:", user);
            if (user) {
                currentUserId = user.uid;
                userIdDisplay.textContent = currentUserId;
                console.log("Authenticated user ID:", currentUserId);
                const today = new Date();
                selectedDateInput.value = today.toISOString().split('T')[0];
                loadReservationsForSelectedDate(selectedDateInput.value);
            } else {
                try {
                    console.log("Attempting anonymous sign-in...");
                    await signInAnonymously(auth);
                    console.log("Anonymous sign-in successful (onAuthStateChanged will be triggered again with user data).");
                } catch (error) {
                    console.error("Firebase authentication error during anonymous sign-in:", error);
                    userIdDisplay.textContent = "인증 실패";
                }
            }
        });

        // Function to generate 30-minute time slots (10:00 to 19:00)
        function generateTimeSlots(startHour, endHour) {
            const slots = [];
            for (let h = startHour; h < endHour; h++) {
                for (let m = 0; m < 60; m += 30) {
                    const hour = String(h).padStart(2, '0');
                    const minute = String(m).padStart(2, '0');
                    slots.push(`${hour}:${minute}`);
                }
            }
            return slots;
        }

        // Function to render time slots
        function renderTimeSlots(allSlots, bookedReservationsMap) {
            timeSlotsDiv.innerHTML = ''; // Clear previous slots
            loadingMessage.style.display = 'none'; // Hide loading message once slots are rendered

            const fragment = document.createDocumentFragment();
            const now = new Date(); // 현재 시간

            allSlots.forEach(slot => {
                const selectedDate = selectedDateInput.value;
                const [selectedYear, selectedMonth, selectedDay] = selectedDate.split('-').map(Number);
                const [selectedHour, selectedMinute] = slot.split(':').map(Number);
                const slotDateTime = new Date(selectedYear, selectedMonth - 1, selectedDay, selectedHour, selectedMinute);

                const existingReservation = bookedReservationsMap[slot];
                const isBookedOrBlocked = !!existingReservation;
                const isBlocked = isBookedOrBlocked && existingReservation.status === 'blocked';
                const isCompleted = isBookedOrBlocked && existingReservation.status === 'completed';
                const isPastSlot = slotDateTime < now; // 과거 시간대인지 확인

                let slotClass = '';
                let statusText = '';
                let serviceText = '';

                if (isPastSlot) {
                    slotClass = 'past-slot';
                    statusText = '예약불가';
                    serviceText = ''; // 과거 시간대는 서비스 내용 표시 안함
                } else if (isCompleted) { // Completed status with new styling
                    slotClass = 'completed';
                    statusText = '완료';
                    serviceText = existingReservation.service ? ` (${existingReservation.service}` : '';
                    if (existingReservation.service === '기타' && existingReservation.customService) {
                        serviceText += `: ${existingReservation.customService}`;
                    }
                    serviceText += ')';
                } else if (isBlocked) {
                    slotClass = 'blocked';
                    statusText = '잠김';
                    if (existingReservation.customService) {
                        serviceText = ` (${existingReservation.customService})`;
                    }
                } else if (isBookedOrBlocked) {
                    slotClass = 'booked';
                    statusText = '예약됨';
                    serviceText = existingReservation.service ? ` (${existingReservation.service}` : '';
                    if (existingReservation.service === '기타' && existingReservation.customService) {
                        serviceText += `: ${existingReservation.customService}`;
                    }
                    serviceText += ')';
                } else {
                    slotClass = 'available';
                    statusText = '예약 가능';
                }

                const slotElement = document.createElement('div');
                // Apply responsive font sizes to time and status text
                slotElement.className = `time-slot-item p-3 rounded-lg text-sm font-medium flex justify-between items-center ${slotClass}`;
                slotElement.innerHTML = `
                    <span class="text-lg sm:text-xl md:text-2xl font-semibold">${slot}</span>
                    <span class="status-text text-sm sm:text-base md:text-lg">${statusText}${serviceText}</span>
                `;
                fragment.appendChild(slotElement);

                // Add click listener to each time slot
                slotElement.onclick = () => {
                    if (isPastSlot) {
                        // showMessageModal("지나간 시간에는 예약할 수 없습니다.", false, null, false); // 자동 닫힘 없이 유지
                    } else if (isBookedOrBlocked) {
                        showBookingManagementModal('existing', slot, existingReservation);
                    } else {
                        showBookingManagementModal('new', slot);
                    }
                };
            });
            timeSlotsDiv.appendChild(fragment);

            if (allSlots.length === 0) {
                timeSlotsDiv.innerHTML = '<p class="text-gray-500 dark:text-gray-400 text-lg sm:col-span-2">날짜를 선택하여 예약 가능한 시간을 확인하세요.</p>';
            }
        }

        // Load reservations for the selected date
        async function loadReservationsForSelectedDate(date) {
            if (!currentUserId) {
                console.warn("User not authenticated yet. Cannot load reservations.");
                return;
            }

            // Show loading indicator immediately
            timeSlotsDiv.innerHTML = ''; // Clear previous content
            loadingMessage.style.display = 'flex'; // Show loading message

            // Unsubscribe from previous listener if exists
            if (unsubscribe) {
                unsubscribe();
            }

            const reservationsRef = collection(db, `artifacts/${appId}/users/${currentUserId}/reservations`);
            const q = query(reservationsRef, where("date", "==", date));

            unsubscribe = onSnapshot(q, (snapshot) => {
                const reservations = [];
                const bookedReservationsMap = {};
                snapshot.forEach(doc => {
                    const data = doc.data();
                    const reservationWithId = { id: doc.id, ...data };
                    reservations.push(reservationWithId);
                    bookedReservationsMap[data.time] = reservationWithId;
                });

                // Sort reservations by time
                reservations.sort((a, b) => a.time.localeCompare(b.time));

                // Business hours: 10:00 to 19:00 (endHour is exclusive, so 19 means up to 18:30 slot)
                const allTimeSlots = generateTimeSlots(10, 19);
                renderTimeSlots(allTimeSlots, bookedReservationsMap);
            }, (error) => {
                console.error("Error fetching reservations:", error);
                loadingMessage.textContent = "예약 정보를 불러오는 중 오류가 발생했습니다.";
                loadingMessage.style.display = 'flex'; // Keep error message visible
                loadingMessage.classList.remove('flex', 'items-center', 'justify-center'); // Remove spinner styling
                const spinnerElement = loadingMessage.querySelector('.spinner');
                if (spinnerElement) spinnerElement.remove(); // Remove spinner
            });
        }

        // Event listener for date selection change
        selectedDateInput.addEventListener('change', (event) => {
            const newDate = event.target.value;
            if (newDate) {
                loadReservationsForSelectedDate(newDate);
            } else {
                timeSlotsDiv.innerHTML = '';
                loadingMessage.style.display = 'flex';
                loadingMessage.innerHTML = '<span class="spinner"></span> 날짜를 선택하여 예약 가능한 시간을 확인하세요.';
            }
        });

        // Handle confirm action button click (for both new booking and blocking time)
        confirmActionBtn.addEventListener('click', async () => {
            // Always close the booking management modal when the confirm button is clicked
            bookingManagementModal.style.display = 'none';

            if (!currentUserId) {
                return;
            }

            const selectedDate = selectedDateInput.value;
            const reservationTime = currentSelectedSlotTime;
            const selectedService = serviceSelect.value;
            let customService = '';

            if (!selectedDate || !reservationTime || !selectedService) {
                return;
            }

            // --- 시간 검증 로직 추가 ---
            const now = new Date();
            const [selectedYear, selectedMonth, selectedDay] = selectedDate.split('-').map(Number);
            const [selectedHour, selectedMinute] = reservationTime.split(':').map(Number);

            const selectedDateTime = new Date(selectedYear, selectedMonth - 1, selectedDay, selectedHour, selectedMinute);

            if (selectedDateTime < now) {
                return;
            }
            // --- 시간 검증 로직 끝 ---

            // Check for existing reservation at the same time slot
            const reservationsRef = collection(db, `artifacts/${appId}/users/${currentUserId}/reservations`);
            const q = query(reservationsRef,
                where("date", "==", selectedDate),
                where("time", "==", reservationTime)
            );
            const querySnapshot = await getDocs(q);

            if (!querySnapshot.empty) {
                return;
            }

            try {
                const reservationData = {
                    date: selectedDate,
                    time: reservationTime,
                    createdAt: new Date().toISOString()
                };

                if (selectedService === '기타') {
                    customService = otherServiceInput.value.trim();
                    if (!customService) {
                        return;
                    }
                    reservationData.service = selectedService;
                    reservationData.customService = customService;
                    reservationData.status = 'booked';
                } else if (selectedService === '개인 시간/휴식 시간 잠금') {
                    customService = blockReasonInput.value.trim();
                    reservationData.service = selectedService;
                    reservationData.customService = customService;
                    reservationData.status = 'blocked';
                } else {
                    reservationData.service = selectedService;
                    reservationData.status = 'booked';
                }

                await addDoc(reservationsRef, reservationData);
            } catch (e) {
                console.error("Error adding document: ", e);
            }
        });

        // Mark reservation as complete from modal
        markCompleteBtnModal.addEventListener('click', async () => {
            // Close the booking management modal immediately
            bookingManagementModal.style.display = 'none';

            if (!currentUserId || !currentSelectedReservationId) {
                return;
            }
            try {
                const reservationDocRef = doc(db, `artifacts/${appId}/users/${currentUserId}/reservations`, currentSelectedReservationId);
                await updateDoc(reservationDocRef, {
                    status: 'completed'
                });
            } catch (e) {
                console.error("Error updating document: ", e);
            }
        });

        // Unblock time from modal
        unblockTimeBtnModal.addEventListener('click', async () => {
            // Close the booking management modal immediately
            bookingManagementModal.style.display = 'none';

            if (!currentUserId || !currentSelectedReservationId) {
                return;
            }
            try {
                const reservationDocRef = doc(db, `artifacts/${appId}/users/${currentUserId}/reservations`, currentSelectedReservationId);
                await deleteDoc(reservationDocRef);
            } catch (e) {
                console.error("Error deleting document: ", e);
            }
        });

        // Delete reservation/block from modal
        deleteReservationBtnModal.addEventListener('click', async () => {
            // Close the booking management modal immediately
            bookingManagementModal.style.display = 'none';

            if (!currentUserId || !currentSelectedReservationId) {
                return;
            }
            try {
                const reservationDocRef = doc(db, `artifacts/${appId}/users/${currentUserId}/reservations`, currentSelectedReservationId);
                await deleteDoc(reservationDocRef);
            } catch (e) {
                console.error("Error deleting document: ", e);
            }
        });

        // Set today's date as default on load
        window.onload = () => {
            const today = new Date();
            selectedDateInput.value = today.toISOString().split('T')[0];
            // loadReservationsForSelectedDate will be called once auth is ready
        };
    </script>
</body>
</html>
